<languages />


{{Metadata|abstract=Ce guide explique comment configurer distcc pour une compilation croisée à travers différentes architectures.}}

Ce guide vous explique comment configurer distcc pour la compilation croisée à travers différentes architectures de processeur.

== La compilation croisée avec distcc ==

=== Introduction ===

<code>distcc</code> est un outil qui vous permet de partager les tâches de compilation d'un logiciel sur plusieurs ordinateurs en réseau. Tant que les ordinateurs en réseau utilisent tous la même chaîne d'outils compilée pour la même architecture, aucune configuration spéciale de <code>distcc</code> n'est requise. Mais que faire pour compiler pour différentes architectures en utilisant des ordinateurs différents ? Ce guide va vous montre comment configurer <code>distcc</code> pour compiler pour différentes architectures. 

=== Installer les utilitaires nécessaires ===

Tout d'abord, vous devez installer <code>crossdev</code> sur toutes les machines qui seront impliquées dans le processus de compilation. <code>crossdev</code> est un outil qui permet une compilation facile de la chaîne des outils de compilation croisée. Il a été écrit à l'origine par Joshua Kinard et a été réécrit totalement par Mike Frysinger. Son utilisation est assez directe : <code>crossdev -t sparc</code> compile une chaîne d'outils complète en ciblant l'architecture Sparc. Ceci inclut binutils, gcc, glibc, et linux-headers. Si vous avez besoin de plus d'aide, essayez d'exécuter  <code>crossdev --help</code> . Évidemment, vous devrez installer la chaîne des outils de compilation croisée  sur tous les ordinateurs participants.

If you want to fine tune the cross-toolchain, here is a script that will produce a command line with the exact versions of the cross development packages to be built on the helper boxes (the script is to be run on the target box).

{{Code|Script to fine-tune cross development tools|<pre>
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B | cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A | cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc | grep $B | cut -d- -f3-`
KERNEL_VER=`uname -r | sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B | cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
</pre>}}

Next, you will need to emerge <code>distcc</code> on all the machines that will be involved in the process. This includes the box that will run emerge and the boxes with the cross-compilers. Please see the [[Distcc|Gentoo Distcc Documentation]] for more information on setting up and using <code>distcc</code>.

=== Arch-specific notes ===

==== Intel x86 subarchitectures ====

If you are cross-compiling between different subarchitectures for Intel x86 (e.g. i586 and i686), you must still build a full cross-toolchain for the desired CHOST, or else the compilation will fail. This is because i586 and i686 are actually different CHOSTs, despite the fact that they are both considered "x86." Please keep this in mind when you build your cross-toolchains. For example, if the target box is i586, this means that you must build i586 cross-toolchains on your i686 helper boxes. 

==== SPARC ====

Utiliser <code>crossdev -t sparc</code> pourrait échouer avec une des erreurs suivantes :

{{Code|Erreurs affichées lors de l'exécution de  crossdev -t sparc|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

Si cela vous arrive, essayez la commande suivante à la place de la précédente :

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== Configurer distcc pour des compilations croisées correctes ===

Dans la configuration par défaut de  distcc, la compilation croisée ne fonctionnera ''pas'' correctement. Le problème est que beaucoup d'ebuilds appellent simplement le compilateur <code>gcc</code> au lieu de l'appeler par son nom complet (par exemple,  <code>sparc-unknown-linux-gnu-gcc</code> ). Quand cette compilation est distribuée sur une machine participante , le compilateur natif est appelé à la place de votre compilateur croisé flambant neuf. 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code>. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note|Les instructions suivantes doivent être exécutées seulement sur la machine qui exécute la commande emerge. N'effectuez pas ces étapes sur les machines assistantes.}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

Voici ce que vous devez faire : 

{{RootCmd|rm c++ g++ gcc cc}}

Ensuite, nous allons créer le nouveau script sur cette machine. Lancez votre éditeur favori et créez un fichier avec le texte suivant, puis sauvegardez-le comme {{Path|sparc-unknown-linux-gnu-wrapper}} . Pensez à remplacer  CHOST (dans ce cas, <code>sparc-unknown-linux-gnu</code> ) par le CHOST réel de la machine qui exécutera la commande emerge. 

{{Code|Le nouveau script enveloppe|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

Ensuite, nous allons rendre le script exécutable  et créer les liens symboliques corrects : 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

Voilà, c'est terminé. {{Path|/usr/lib/distcc/bin}} devrait ressemble à ceci : 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Next we want to make sure that these wrappers stay available after upgrading the distcc package as it will overwrite the symbolic links. We can do this through a {{Path|/etc/portage/bashrc}} file that looks like so:

{{Code|/etc/portage/bashrc|<pre>
case ${CATEGORY}/${PN} in
	sys-devel/distcc)
		# Hey man, how come that CONFIG PROTECT don't work?
		if [ "${EBUILD_PHASE}" == "postinst" ] || [ "${EBUILD_PHASE}" == "postrm" ];
		then
			cd /usr/lib/distcc/bin
			rm cc c++ gcc g++
			ln -s sparc-unknown-linux-gnu-wrapper cc
			ln -s sparc-unknown-linux-gnu-wrapper c++
			ln -s sparc-unknown-linux-gnu-wrapper gcc
			ln -s sparc-unknown-linux-gnu-wrapper g++
		fi
	;;
esac</pre>
}}

Félicitations ! Vous disposez maintenant d'une configuration distcc de compilation croisée fonctionnelle.

=== Comment ça marche ===

Lorsque <code>distcc</code> est appelé, il recherche ce qui est appelé  (par exemple <code>i686-pc-linux-gnu-gcc</code> , <code>sparc-unknown-linux-gnu-g++</code> , etc.) Lorsque distcc distribue ensuite la compilation à une machine assistante, il lui passe le nom par lequel il a été appelé. Le démon distcc sur l'autre machine assistante recherche alors un binaire de ce nom. S'il voit simplement  <code>gcc</code> , il cherchera  <code>gcc</code> , qui est probablement le compilateur natif sur la machine assistante, si ce n'est pas la même architecture que celle de la machine exécutant la commande  <code>emerge</code> . Quand le nom ''complet'' du compilateur est envoyé, (par exemple,  <code>sparc-unknown-linux-gnu-gcc</code> ), il ne peut y avoir de  confusion.

== Remerciements ==

Nous tenons à remercier les auteurs et éditeurs suivants pour leur contribution à ce guide :

* Andrew Gaffney
* Joshua Saddler
