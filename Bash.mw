{{InfoBox stack
|{{InfoBox homepage|http://www.gnu.org/s/bash|header=true}}
|{{InfoBox wikipedia|Bash_(Unix_shell)}}
}}
'''GNU Bash''' ('''B'''ourne-'''a'''gain '''sh'''ell) is a [[shell]] program. It is the first program started if someone logs in at a terminal. Which user uses what shell is defined in the file {{Path|/etc/passwd}}. It enables users to easier interact with the system and start additional programs. A lot of this information also applies to other shells like [[zsh]].

== Installation ==
{{Package|app-shells/bash}} is part of the ''system'' set and so already installed on your system. It is also used by [[portage]], Gentoo's default package manager, so it is not recommended to uninstall it, even if you use another shell as login-shell.

But you can change the USE flags:
{{USEflag|package=app-shells/bash
|afs
|bashlogger
|examples
|mem-scramble
|net+yes+yes
|nls+yes
|plugins
|readline+yes+yes
|vanilla++no
}}

After setting this you want to update your system so the changes take effect:
{{Emerge|params+=--changed-use --deep|@world}}

== Configuration ==

=== Shell ===
The default shell for a user is defined in {{Path|/etc/passwd}}. It can be changed using '''chsh''', which is part of {{Package|sys-apps/coreutils}}.

=== Configs ===
Many settings on how the shell behaves, can be defined via variables. Those variables are defined in several different configuration files, where the settings in the last file parsed do overwrite previous definitions.

* {{Path|/etc/profile}} - initial settings for all users
* {{Path|/home/USER/.bash_profile}} - settings for this user
* {{Path|/home/USER/.bash_login}} - settings for this user, if {{Path|/home/USER/.bash_profile}} doesn't exist
* {{Path|/home/USER/.profile}} - settings for this user, if {{Path|/home/USER/.bash_profile}} and {{Path|/home/USER/.bash_login}} don't exist
If the shell is started without login (e.g. in a terminal on a desktop), the following files are used
* {{Path|/etc/bashrc}} - initial settings for all users
* {{Path|/home/USER/.bashrc}} - settings for this user
In Gentoo any many other distributions {{Path|/etc/bashrc}} is parsed in the {{Path|/etc/profile}} to ensure that {{Path|/etc/bashrc}} and {{Path|/home/USER/.bashrc}} are always checked when someone logs into the system. The final settings are defined by the user in their {{Path|.bashrc}}

=== .bashrc ===
Example of a {{Path|/home/USER/.bashrc}}
{{File|/home/USER/.bashrc||<pre>
# configure PS1 command prompt
export PS1="\u@\h \w \$ "

# no double entries in the shell history
export HISTCONTROL="$HISTCONTROL erasedups:ignoreboth"

# do not overwrite files when redirecting output
set -o noclobber

# ask before performing the following command
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'</pre>}}


=== Tab completion ===
bash-completion adds completion to many programs and their parameters.
{{emerge|bash-completion}}

You need to add the following line to your .bashrc to load bash-completion.
{{file|~/.bashrc||<pre>
source /etc/profile.d/bash-completion.sh
</pre>}}

Now you can enable completion for various programs with eselect.
{{cmd|eselect bashcomp enable gentoo}}

== Usage ==

=== Environment Variables ===
See all defined variables for this user (not all are shell related):
{{Cmd|printenv}}
Of course users can define their own variables, which are readily available in memory until the end of the session (terminal closes):
{{Cmd|export MYSTUFF{{=}}'Hello'}}
In the previous command we used ''export'' to have the variable for the whole session, if this is not needed you can just define the variable and the information will be released when the command finished execution:
{{Cmd|USE{{=}}"kde" emerge -pv libreoffice}}
To check the value of a variable:
{{Cmd|echo $MYSTUFF}}
{{Note|To have variables set in every session, the file {{Path|/home/USER/.bashrc}} should be used.}}

=== PS1 ===
The environment variable ''PS1'' defines how the prompt looks like. The prompt is everything displayed in from of the blinking cursor in the console:
{{Code|Prompt|MyUserName@MyPC: ~ $}}
This prompt would be the following value in '''PS1''':
{{Code|PS1|PS1{{=}}"\u@\h \w $"}}
{{Note|the '''~''' symbol represents the home directory {{Path|/home/USER/}}}}

The following table lists the possible placeholders you can use in your '''PS1''' variable:
{| class=wikitable
|- 
| Code
| Effect
|-
| \u
| Username
|-
| \h
| Hostname
|-
| \w
| Current directory
|-
| \d
| Current date
|-
| \t
| Current time
|-
| \$
| Indicate the root user with '#' and normal users with '$'
|-
| \j
| Number of currently running tasks (jobs)
|}
You can also put complete commands into your prompt using a subshell. Here we want to execute ''uname -s'' to show system information in the prompt:
{{Code|PS1|PS1{{=}}"\$(uname -s) $"}}
Having colours in the prompt:
{{Code|PS1|PS1{{=}}"\e[0;32m\]\u@\h \w >\e[0m\]"}}
The '''\e[0;32m\]''' changes the colour for every next output, we have to put '''\e[0m\]''' at the end of our variable to reset the colour, or we would type everything in green.

Colour codes:
{| class=wikitable
|-
| Code
| Colour
|-
| \e[0;30m\]
| Black
|-
| \e[0;37m\]
| White
|-
| \e[0;31m\]
| Red
|-
| \e[0;32m\]
| Green
|-
| \e[0;33m\]
| Yellow
|-
| \e[0;34m\]
| Blue
|-
| \e[0m\]
| Reset to standard colours
|}
The '''0;''' in '''\e[0;31m\]''' means foreground. You can define other values like '''1;''' for foreground bold and '''4;''' for foreground underlined. Omit this number to refer to the background, e.g. '''\e[31m\]'''.

=== set ===
Display and change settings in the Bash shell
* {{Cmd|set -o}} - Show all current settings
* {{Cmd|set +o history}} - disable the shell history
* {{Cmd|set -o history}} - enable the shell history

=== alias ===

You can use the <code>alias</code> builtin to define a new command or redefine an existing command:
{{Cmd|<nowiki>alias ll='ls -l'</nowiki>}}
Whenever now '''ll''' is send to the shell, it will actually execute '''ls -l'''.

To remove an alias:
{{Cmd|unalias ll}}

{{Note|No harm is done to the actual command being redefined.}}

If you want to temporarily bypass an alias you can escape the first letter of the command with a backslash character:
{{Cmd|\ls}}

=== history ===
The history of used commands in a session is written to a file in the user home directory. The easiest way to access the commands in the history is using the {{Key|Up}} and {{Key|Down}} keys.
To show all commands in the current history:
{{Cmd|history}}
To search for commands in the history, by piping the output through '''grep''' and filter for words:
{{Cmd|<nowiki>history | grep echo</nowiki>}}
The commands are numbered and can be executed using their index:
{{Cmd|!2}}
To execute the last command used:
{{Cmd|!!}}
Delete every command in the history:
{{Cmd|history -c}}
Show the current settings for history:
{{Cmd|echo $HISTCONTROL}}

== Scripts ==

Shell scripts are text files which contain programs written in a certain shell scripting language. Which shell is used to interpret the commands in a script is defined in the first line (which is called the shebang):

{{File|MyScript.sh||<pre>
#!/bin/bash
echo 'Hello World!'
</pre>}}

If no shell is defined the default shell for the user who executes the script is used. Often '''/bin/sh''' is used, which is the father of all shells and has very limited functionalities. Nearly all shells available understand commands used when running '''/bin/sh''', so those scripts are highly portable.

{{Note|On many distributions '''/bin/sh''' is a symbolic link to '''/bin/bash'''.}}

=== Start Scripts ===
To start scripts, they need to be executable. To make a shell script executable:
{{Cmd|chmod +x MyScript.sh}}
Now it can be executed by using the '''./''' prefix, where either the shell defined by the shebang in the script or the default shell of the user is used:
{{Cmd|./MyScript.sh}}
In alternative you can explicitely invoke the shell and pass the script filename as an argument (no change of permissions needed):
{{Cmd|sh MyScript.sh}}
The file extension ''.sh'' does not matter, but it helps to distinguish scripts from normal text files.

=== Redirection ===

In Bash it is possible to redirect the output of one program into the input of another program using a pipe, indicated by the '''|''' symbol. This enables users to create command chains. Here is an example to redirect the output of '''ls -l''' into the program '''/usr/bin/less''':
{{Cmd|<nowiki>ls -l | less</nowiki>}}

To redirect output into a file:
{{Cmd|ls -l > ls_l.txt}}

The '''>''' operator will erase any previous content before adding new one. If this is not desired, use the '''>>''' (append) operator instead.

=== Logical operators ===
Very useful to chain commands are logical operators, to check if the previous command finished successfully or not:
* <code>&&</code> (AND) - The following command prints 'Success' only if our test script is successful:
: {{Cmd|./MyScript.sh && echo 'Success'}}
* <code>||</code> (OR) - The following command prints 'Failure' only if our test script is unsuccessful: 
: {{Cmd|<nowiki>./MyScript.sh || echo 'Failure'</nowiki>}}

=== Jobs and Subshell ===
Usually if we start a script or command, the input is blocked until the command is finished. To start a program directly in the background, so we can continue to work in the shell:
{{Cmd|sh MyScript.sh &}}
This will execute the script as '''job''' number 1 and the prompt expects the next input.

If a program is already running and you need to do something on the shell, it is possible to move programs from ''foreground'' to ''background'' and vice versa. To get a command prompt if a command is running on the shell, put it into ''sleep'' using {{Key|Ctrl}}+{{Key|Z}}, then move it to the background:
{{Cmd|bg %1}}
To list all jobs running in the background:
{{Cmd|jobs}}
To move a job back to foreground:
{{Cmd|fg %1}}
{{Note|Programs running as jobs usually do not terminate once they finish execution, there will be a message if a job finished and bringing it to foreground will then terminate the program.}}
Using a sub shell, it is possible to run programs as parameters of other commands like here:
{{Cmd|emerge $(qlist -C -I x11-drivers)}}
This will first execute the commands in the brackets and append the output as parameter of emerge
{{Note|This command is quiet useful in Gentoo to quickly rebuild all X11 drivers.}}
You can run more subshells parallel at a time like this:
{{Cmd|emerge $(qlist -C -I x11-drivers) $(qlist -C -I modules)}}

== See also ==
Bash is the default shell for Gentoo Linux, and the language upon which its [http://dev.gentoo.org/~ulm/pms/head/pms.html package manager specification] is built.
* Short [http://devmanual.gentoo.org/tools-reference/bash/index.html Bash reference] from the Gentoo dev manual.

== External resources ==
* [http://tldp.org/LDP/abs/html/ Advanced Bash-Scripting Guide]
* [http://tiswww.case.edu/php/chet/bash/bashtop.html Chet's Bash page]
* Official [http://www.gnu.org/software/bash/manual/bash.html Bash documentation]
* The [http://mywiki.wooledge.org/BashFAQ Bash FAQ] and [http://mywiki.wooledge.org/BashGuide Bash guide] on Greg Wooledge's wiki.
* [http://wiki.bash-hackers.org bash-hackers] wiki (very good reference)
* [http://git.savannah.gnu.org/cgit/bash.git Bash cgit]
* [http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html POSIX sh] spec
* [https://www.mirbsd.org/man/mksh.1 mksh], [http://www2.research.att.com/sw/download/man/man1/ksh.html ksh93], and [http://www2.research.att.com/sw/download/man/man1/ksh88.html ksh88] manuals for cross-reference.

[[Category:Shell]]
