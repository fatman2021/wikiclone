<languages />

UTF-8 это кодировка символов переменной длины, что, в данном случае, означает длину от 1 до 4 байт на символ. Первый байт UTF-8 используется для кодирования ASCII, что означает, что данный набор символов полностью обратно совместим с ASCII. UTF-8 означает, что символы ASCII и Latin полностью взаимозаменяемы с небольшим увеличением размера данных, так как используется только первый бит. Пользователи Восточных алфавитов, например, Японского, которым назначили диапазон с большим числом байт несчастливы, так как это приводит к 50%-избыточности в их данных. 

== Кодировки символов ==

=== Что такое Кодировка Символов? ===

Компьютеры неспособны воспринимать текст. Вместо этого они каждый символ представляют как число. Традиционно каждый набор чисел, соответствующий алфавиту и символам (известный как кодировка или набор символов), ограничен в размере в силу ограничений оборудования. 

=== История кодировок символов ===

Самой распространенной (или, по крайней мере, наиболее принятой повсеместно) кодировкой является '''ASCII''' (Американский стандартный код для обмена информацией, American Standard Code for Information Interchange). Часто считается, что ASCII &mdash; наиболее успешный программный стандарт современности. Нынешний ASCII стандартизован в 1986 году (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) Американским национальным институтом по стандартизации (American National Standards Institute, ANSI). 

ASCII является строго семибитной кодировкой, из чего следует, что она использует семь двоичных цифр, то есть интервал от 0 до 127. ASCII начинается с 32 невидимых управляющих символов (с кодами от 0 до 31) и заканчивается управляющим символом DEL (или delete) с кодом 127. Символы в диапазоне от 32 до 126 видимы &mdash; это пробел, знаки препинания, латинские буквы и цифры. 

Восьмой бит в ASCII изначально использовался как бит целостности для проверки ошибок при передаче информации. Если целостность была не важна, он всегда равнялся 0. Это означает, что в ASCII каждый символ занимал один байт. 

Хотя ASCII было достаточно для передачи информации на английском, для других европейских языков, содержащих символы с ударениями, это было не так просто. Для них был разработаны стандарты семейства ISO 8859. Они были обратно совместимы с ASCII, но использовали восьмой бит для дополнения таблицы дополнительными 127 символами для каждой кодировки. Скоро стали видны и ограничения ISO 8859. На данный момент существует 15 вариантов стандарта ISO 8859 (от 8859-1 до 8859-15). Однако для каждого символа вне ASCII-совместимого диапазона между этими стандартами возникал конфликт. Чтобы еще больше усилить конфликт между различными кодировками, для восточноевропейских языков корпорацией Microsoft был введен набор Windows-1252, использованный в ранних версиях Windows. Этот набор является надстройкой ISO 8859-1, обладающий собственными изменениями. Однако все же эти наборы были совместимы с ASCII. 

Необходимость разработки совершенно отличных от ASCII однобайтовых кодировок для нелатинских алфавитов, как например EUC (Extended Unix Coding), используемый в японском и корейском (и в меньшей степени китайском) алфавитах, породила еще большую неразбериху с кодировками, из-за чего ряд операционных систем все еще использует различные наборы символов для одного и того же языка, например японские Shift-JIS и ISO-2022-JP. А пользователи, желающие видеть кириллицу, вынуждены были выбирать между KOI8-R (для русского и болгарского языков) и KOI8-U (для украинского языка), неудачной ISO 8859-5 и популярной Windows-1251. Все три семейства кодировок не полностью совместимы с ASCII (хотя в KOI8 фонетически созвучные кириллические символы расположены так же, как и латинские, благодаря чему даже при отбрасывании восьмого бита текст оставался читабельным в ASCII-терминалах в виде транслита). 

Все это привело к путанице и полной невозможности многоязычного общения, в особенности с использованием различных алфавитов. Переходим к Юникоду. 

=== Что такое Юникод? ===

Юникод отбрасывает лимит традиционных однобайтовых кодировок. Он использует 17 "плоскостей", содержащих по 65,536 кодов символов. Таким образом, максимальное возможное число символов равно 1,114,112. Поскольку в первой плоскости ("Basic Multilingual Plane" или BMP) содержится почти всё, что вам может понадобиться, многие ошибочно посчитали, что Юникод это 16-битный набор символов. 

Юникод реализован несколькими способами, но распространены только два '''UTF''' (Unicode Transformation Format) и '''UCS''' (Universal Character Set). Число после UTF обозначает число бит на каждый символ, когда как число после UCS обозначает число байт. UTF-8 стала наиболее распространенной при обмене текста Юникод из-за своей явной ориентированности на размер в 8 бит, поэтому она и является основной темой данного документа. 

=== Что UTF-8 может сделать для вас ===

UTF-8 позволяет вам работать в совместимой со всеобщими стандартами и принятой по всему миру многоязычной среде, правда с небольшим увеличением размера данных. UTF-8 это наилучший способ для передачи не-ASCII символов через интернет, будь то электронная почта, IRC-сети или что-нибудь еще. Несмотря на это, множество людей расценивают использование UTF-8 при передаче данных неприличным и неуважительным. Всегда следует выяснять, поддерживает ли определенный канал, группа Usenet или список рассылки UTF-8 перед тем, как использовать символы из ''не-ASCII'' диапазона UTF-8. 

== Включение UTF-8 в Gentoo Linux ==

=== Поиск или создание локалей UTF-8 ===

Теперь, когда вы поняли основы Юникода, вы готовы начать использование UTF-8 в вашей системе. 

Главным требованием для UTF-8 является наличие установленной библиотеки glibc с поддержкой национального языка. При этом рекомендуется использовать файл {{Path|/etc/locale.gen}}. Описание использования этого файла, однако, выходит за рамки данного документа. Его использование описано в [[Localization/HOWTO|Руководстве по локализации Gentoo]] 

Далее, нужно определить, доступна ли локаль UTF-8 для нашего языка или придётся её создать. 

{{Cmd|locale -a {{!}} grep 'ru_RU'|output=<pre>
ru_RU
ru_RU.UTF-8
</pre>
}}

На выходе этой команды мы должны получить хотя бы одну строку, содержащую суффикс <c>.UTF-8</c>. Если таковых нет, то нам придётся создать локаль, совместимую с UTF-8. 


{{Note/ru|Запускайте следующую команду, если у вас нет UTF-8 локали для вашего языка}}

Замените "ru_RU", если вам нужна какая-то другая локаль:
{{RootCmd|localedef -i ru_RU -f UTF-8 ru_RU.UTF-8}}

Другим способом включить локаль UTF-8 является добавление её в файл {{Path|/etc/locale.gen}} и генерация нужных локалей командой <code>locale-gen</code>. 

{{Code/ru|Строка в /etc/locale.gen|<pre>
ru_RU.UTF-8 UTF-8
</pre>
}}

=== Настройка локали ===

Есть одна переменная среды, которую необходимо установить, чтобы использовать UTF-8 локали: <code>LC_CTYPE</code> (или, опционально, переменную <code>LANG</code>, если вы хотите заодно изменить и системный язык). Есть множество способов сделать это. Некоторые люди предпочитают использовать UTF-8 только для определенного пользователя, поэтому они устанавливают эту переменную в своём {{Path|~/.profile}} (если используется <code>/bin/sh</code>), {{Path|~/.bash_profile}} или {{Path|~/.bashrc}} (если используется <code>/bin/bash</code>). Большее количество информации, а также наилучшие способы локализации можно найти в нашем [[Localization/HOWTO|Гайде по Локализации]]. 

Другие предпочитают установить локаль глобально. Есть по крайней один весомый аргумент в пользу этого подхода - при использовании {{Path|/etc/init.d/xdm}}, так как сценарии инициализации запускают диспетчер окон до того, как будут загружены конфигурационные файлы командной оболочки, и, поэтому, до того момента, как какие-либо переменные попадут в окружение пользователя. 

При установке глобальной локали должен быть использован файл {{Path|/etc/env.d/02locale}}. Он должен выглядеть следующим образом: 

{{Code/ru|Демонстрация /etc/env.d/02locale|<pre>
## (Как обычно, замените "ru_RU.UTF-8" на нужную локаль)
LANG="ru_RU.UTF-8"
</pre>
}}

{{Note/ru|Вы можете также указывать <code>LC_CTYPE</code> вместо <code>LANG</code>. За дополнительными сведениями о категориях, затронутых использованием <code>LC_CTYPE</code>, пожалуйста, обращайтесь к 
[http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories странице локалей GNU].}}

Далее следует обновить среду. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Теперь запустите <code>locale</code> без аргументов, чтобы увидеть, что у вас верные переменные среды: 

{{RootCmd|locale|output=<pre>
LANG=ru_RU.UTF-8
LC_CTYPE="ru_RU.UTF-8"
LC_NUMERIC="ru_RU.UTF-8"
LC_TIME="ru_RU.UTF-8"
LC_COLLATE="ru_RU.UTF-8"
LC_MONETARY="ru_RU.UTF-8"
LC_MESSAGES="ru_RU.UTF-8"
LC_PAPER="ru_RU.UTF-8"
LC_NAME="ru_RU.UTF-8"
LC_ADDRESS="ru_RU.UTF-8"
LC_TELEPHONE="ru_RU.UTF-8"
LC_MEASUREMENT="ru_RU.UTF-8"
LC_IDENTIFICATION="ru_RU.UTF-8"
LC_ALL=
</pre>
}}

Вот и всё. Теперь вы используете локаль UTF-8, и следующим этапом является настройка повседневно используемых вами приложений. 

== Поддержка приложениями ==

Когда Юникод делал первые шаги в мире программного обеспечения, и многобайтовые кодировки еще не были включены в языки программирования, наподобие C, на котором написаны многие из повседневно используемых программ. Даже сейчас некоторые программы не способны работать с UTF-8 как надо. К счастью, таких не так много! 

=== Имена файлов, NTFS и FAT ===

В в конфигурационном меню ядра Linux есть множество параметров NLS, но главное не паниковать! В большинстве случаев всё, что вам нужно - включить поддержку UTF-8 NLS в ваше ядро и изменить NLS по умолчанию на utf8. 

{{Kernel/ru|Шаги настройки UTF-8 NLS для ядра|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Также пометьте <*> другие наборы символов, которые вы используете
    в вашей файловой системе FAT или Joilet для CD-ROM.)
</pre>
}}

Если вы планируете монтировать разделы NTFS, то вам понадобиться указать параметр при монтировании <code>nls=</code>. Если вы будете монтировать разделы FAT, вам понадобится указать при монтировании параметр <code>codepage=</code>. Также вы можете установить для FAT кодовую страницу по умолчанию при конфигурации ядра. Помните, что параметр <code>codepage</code>, указываемый при монтировании, будет иметь приоритет над настройками ядра. 

{{Kernel/ru|Настройки FAT в конфигурации ядра|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

Не устанавливайте <code>Default iocharset for fat</code> в UTF-8, так как это не рекомендуется. Вместо этого укажите параметр utf8=true при монтировании раздела FAT. Для более детальной информации, смотрите <code>man mount</code> и документацию по ядру {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}}. 

Чтобы сменить кодировку имен файлов, используйте <code>app-text/convmv</code>. 

{{Emerge|app-text/convmv}}

Команда <code>convmv</code> имеет следующий формат:

{{RootCmd|convmv -f &lt;текущая кодировка&gt; -t utf-8 &lt;имя файла&gt;}}

Замените koi8-r кодировкой, с которой хотите конвертировать:

{{RootCmd|convmv -f koi8-r -t utf-8 имя_файла}}

Для изменения ''содержимого'' файлов, используйте утилиту <code>iconv</code>, поставляемую вместе с <code>glibc</code>. Замените koi8-r кодировкой, с которой хотите конвертировать, и проверьте вывод программы:

{{RootCmd|iconv -f koi8-r -t utf-8 имя_файла}}

Чтобы преобразовать файл, вы должны создать другой файл:

{{RootCmd|iconv -f koi8-r -t utf-8 имя_файла &gt; новый_файл}}

Также для этой цели может быть использована утилита <code>app-text/recode</code>. 

=== Системная консоль ===

{{Important/ru|Вам необходим sys-apps/baselayout версии 1.11.9 или более высокой для поддержки Юникода в консоли.}}

Для включения UTF-8 в консоли вы должны отредактировать {{Path|/etc/rc.conf}} и установить переменную <code>UNICODE="yes"</code>. Также прочтите комментарии в этом файле - важно, чтобы в системе были шрифты с нужным диапазоном символов, если вы хотите выжать из Юникода всё. Чтобы это сработало, удостоверьтесь, что вы правильно создали локаль Unicode. 

В файле {{Path|/etc/conf.d/keymaps}} переменной <code>KEYMAP</code> должна соответствовать раскладка Unicode. 

{{Code/ru|Выдержка из /etc/conf.d/keymaps|<pre>
## (Замените ru4 на вашу любимую раскладку)
keymap="ru4"
</pre>
}}

=== Ncurses и Slang ===

{{Note/ru|Если вы не устанавливали или не используете slang, не принимайте во внимание упоминания о нём в этом разделе.}}

Будет хорошим решением добавить <code>unicode</code> к глобальным USE-флагам в файле {{Path|/etc/portage/make.conf}}, а затем при необходимости пересобрать <code>sys-libs/ncurses</code> и <code>sys-libs/slang</code>. Portage это сделает автоматически при обновлении системы: 

{{RootCmd|emerge --update --deep --newuse world}}

Также понадобится пересобрать пакеты, зависящие от них, раз изменения USE	вступили в силу. Используемая утилита (<code>revdep-rebuild</code>) входит в пакет <code>gentoolkit</code>. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME и Xfce ===

Все основные графические оболочки полностью совместимы с Юникодом и не требуют дополнительной настройки, кроме той, что описана в этом документе. Все это	благодаря тому, графические библиотеки (Qt и GTK+2) совместимы с UTF-8. Следовательно, все приложения, работающие на основе этих библиотек, также должны поддерживать UTF-8 без дополнительных настроек. 

Исключением в этом правиле является Xlib и GTK+1. GTK+1 требует iso-10646-1 FontSpec в ~/.gtkrc, например <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code>. Также приложения, использующие Xlib или Xaw, нуждаются в подобной FontSpec, иначе они не буду работать. 

{{Note/ru|Если у вас установлен центр управления gnome1, используйте его. Воспользуйтесь любым из шрифтов семейства iso10646-1.}}

{{Code/ru|Пример ~/.gtkrc (для GTK+1), определяющий Юникод-совместимый шрифт|<pre>
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
</pre>
}}

Если приложение одинаково поддерживает Qt и GTK+2, то обычно GTK+2 GUI выдает лучшие результаты при работе с Юникодом. 

=== X11 и шрифты ===

Шрифты TrueType обычно совместимы с Юникодом, и большинство шрифтов, поставляемых с Xorg, имеют великолепную поддержку кодировок, хотя не все глифы Юникода могут быть отображены для конкретного шрифта. Чтобы собрать шрифты с поддержкой Восточноазиатских алфавитов (включающие набор Bitstream Vera) для X-сервера, добавьте USE-флаг <code>cjk</code>. Много приложений используют этот флаг, поэтому неплохо бы внести его как постоянный флаг. 

Также несколько пакетов шрифтов в Portage совместимы с Юникодом. 

{{Emerge|terminus-font intlfonts freefonts corefonts}}

=== Диспетчеры окон и эмуляторы терминалов ===

Диспетчеры окон, не использующие GTK или Qt, обычно очень хорошо поддерживают Юникод, так как чаще всего для отображения шрифтов используют библиотеку Xft. Если ваш диспетчер окон не использует Xft, то вы все еще можете использовать FontSpec, указанный в предыдущем разделе в качестве шрифта Юникода. 

Эмуляторы терминала, использующие Xft и поддерживающие Юникод найти сложнее. Кроме Konsole и gnome-terminal, лучшим выбором в Portage будет <code>x11-terms/rxvt-unicode</code>, <code>x11-terms/terminal</code>, <code>gnustep-apps/terminal</code>, <code>x11-terms/mlterm</code> или чистый <code>x11-terms/xterm</code>, собранный с USE-флагом <code>unicode</code> и запускаемый как <code>uxterm</code>. <code>app-misc/screen</code> тоже поддерживает UTF-8, если запускается с параметром <code>screen -U</code>, или в файле {{Path|~/.screenrc}} есть следующая строчка: 

{{Code/ru|~/.screenrc для UTF-8|<pre>
defutf8 on
</pre>
}}

=== Vim, Emacs, Xemacs и Nano ===

Vim полностью поддерживает UTF-8 и к тому же автоматически определяет файлы с UTF-8. Для более детальной информации используйте в Vim <code>:help mbyte.txt</code>. 

Emacs версии 23 и Xemacs версии 21.5 имеют полную поддержку UTF-8. Emacs 24 также будет поддерживать редактирование текста в обоих направлениях. 

Nano полностью поддерживает UTF-8 начиная с версии 1.3.6. 

=== Командные оболочки ===

На данный момент <code>bash</code> полностью поддерживает Юникод через библиотеку GNU readline. Z Shell (<code>zsh</code>) поддерживает Unicode при использовании USE-флага <code>unicode</code>. 

Оболочки C, <code>tcsh</code> и <code>ksh</code> не поддерживают UTF-8. 

=== Irssi ===

Irssi полностью поддерживает UTF-8, хотя для этого требуется дополнительная настройка пользователем. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

Для каналов, где не-ASCII символы чаще всего передаются в не-UTF-8 кодировках, может пригодиться команда <code>/recode</code> для перекодировки символов. Наберите <code>/help recode</code> для большего количества информации. 

=== Mutt ===

Почтовый агент Mutt очень хорошо справляется с Юникодом. Чтобы использовать UTF-8 в Mutt, вам нет необходимости что-либо добавлять в конфигурационные файлы. Mutt будет работать с Юникодом без модификаций, при условии, что все ваши конфигурационные файлы (включая подпись) сохранены в UTF-8. 

{{Note/ru|Вы всё ещё можете видеть знаки вопроса при чтении почты с помощью Mutt. Это случается из-за того, что некоторые люди используют почтовые клиенты, не устанавливающие используемую кодировку письма. Вы ничего больше не можете сделать, кроме как попросить их правильно настроить свои клиенты.}}

Для более детальной информации смотри [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki]. 

=== Man ===

Man-страницы являются неотъемлемой частью любой системы Linux. Чтобы удостовериться, что все страницы отображаются верно, отредактируйте {{Path|/etc/man.conf}} и замените следующую строку. 

{{Code/ru|Изменения man.conf для поддержки Юникода|<pre>
## (Это старая строка)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Замените ее этой)
NROFF           /usr/bin/nroff -mandoc -c
</pre>
}}

=== elinks и links ===

Это самые популярные текстовые браузеры, и вы узнаете, как установить поддержку UTF-8 для них. В <code>elinks</code> и <code>links</code> есть два способа сделать это - через меню Setup (Установки) браузера или отредактировав конфигурационный файл. Чтобы настроить параметры в самом браузере, откройте какой-нибудь сайт с помощью <code>elinks</code> или <code>links</code> и нажмите <code>Alt+S</code>. Вы попадете в меню настроек (Setup Menu), после чего выберите параметры терминала (Terminal options), или нажмите <code>T</code>. Пролистайте вниз и выберите последний параметр <code>UTF-8 I/O</code>, нажав на Enter. Затем сохраните и выйдите из меню. В <code>links</code> вы можете сделать то же самое, нажав <code>Alt+S</code>, а затем <code>S</code> для сохранения. Пример конфигурационного файла показан ниже. 

{{Code/ru|Включение UTF-8 в elinks/links|<pre>
## (Для elinks добавьте в /etc/elinks/elinks.conf или ~/.elinks/elinks.conf следующую строку)
set terminal.linux.utf_8_io = 1

## (Для links добавьте ~/.links/links.cfg следующую строку)
terminal "xterm" 0 1 0 us-ascii utf-8
</pre>
}}

&nbsp;

=== Samba ===

Samba это набор программ, реализующих протокол SMB (Server Message Block) для UNIX-систем (Mac, Linux и FreeBSD). Этот протокол также иногда упоминается как Common Internet File System (CIFS). Samba содержит также систему NetBIOS, используемую для предоставления доступа к файлам в Windows-сетях. 

Добавьте следующее в раздел [global]:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Проверка работоспособности ===

Есть множество сайтов, использующих UTF-8. <code>net-www/w3m</code>, <code>net-www/links</code>, <code>net-www/elinks</code>, <code>net-www/lynx</code>, все браузеры, основанные на движке Mozilla (включая Firefox) поддерживают UTF-8. Konqueror и Opera тоже полностью поддерживают UTF-8. 

При использовании текстовых браузеров, удостоверьтесь, что используете совместимый с Юникодом терминал. 

Если вы видите символы, отображаемые как квадратики с буквами или цифрами	внутри, то это значит, что в ваших шрифтах нет соответствующего глифа для	символа. Вместо этого, они отображают квадрат с шестнадцатиричным кодом символа UTF-8. 

*  [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html Тестовая страница UTF-8 W3C]
*  [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm Тестовая страничка UTF-8 от Университета Франкфурта] 

=== Ввод символов ===

''Dead keys'' могут быть использованы для ввода символов, не отображенных на клавиатуре, в X-сервере. Для этого нужно, удерживая правый Alt (в некоторых странах он называется AltGr), нажать на дополнительную неалфавитную клавишу с символом, не являющимся буквой или цифрой (модификатор), а затем нажать на необходимую букву. Dead key изменит ее. Ввод может быть изменен также с помощью Shift при нажатых AltGr и модификаторе. 

Чтобы включить dead keys в X, нужно иметь раскладку, поддерживающую их. Большинство европейских раскладок уже имеют dead keys по умолчанию. Тем не менее, это не так в североамериканских раскладках. Хотя	существуют незначительные отличия между различными раскладками, простейшим решением будет использование раскладки в форме "en_US" вместо просто "us". Раскладка указывается в {{Path|/etc/X11/xorg.conf}}: 

{{Code/ru|Пример раздела /etc/X11/xorg.conf|<pre>
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" ## Вместо просто "us"
    ## (Другие параметры Xkb)
EndSection
</pre>
}}

{{Note/ru|Эти изменения нужны только в том случае, если вы используете североамериканскую раскладку либо любую другую, в которой dead keys не работают. Европейским пользователям нет нужны что-либо менять.}}

Изменения вступят в силу только при перезагрузке X-сервера. Чтобы изменения вступили немедленно, используйте утилиту <code>setxkbmap</code>, например, <code>setxkbmap en_US</code>. 

Рассмотрим действия dead keys на примерах. Хотя результат зависит от текущей локали, сам принцип действия должен работать в нее зависимости от нее. Примеры содержат символы Юникода, так что убедитесь, что ваш браузер корректно отображает их. 

При нажатии единожды нажатых AltGr и &#91;, а затем нажатой "a" мы получаем 'ä'. При единожды нажатых AltGr и &#91;, а затем нажатой "e", получаем 'ë'. Нажав на AltGr и ;, мы получим 'á', а нажав AltGr и ;, а затем на "e", получаем 'é'. 

Нажав на AltGr, Shift и &#91;, отпустив их и нажав "a", мы получим скандинавскую 'å'. Также при нажатии AltGr, Shift и &#91;, отпускании ''только'' &#91; и повторном ее нажатии мы получим только '°'. Хотя этот символ (U+02DA) и похож на символ градуса (U+00B0), на самом деле он им не является.

AltGr может быть использована вместе с одной из алфавитных клавиш. Например, комбинация AltGr и m выводит греческую строчную букву мю. AltGr и s выводит немецкий символ эсцет. Множество европейцев захотят установить	сочетание AltGr и 4 (или E в зависимости от клавиатурный таблицы), выводящее символ Евро, '€' (так как на их клавиатурах он нанесен). 

=== Ссылки ===

*  [http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4 Заметка Википедии по Юникоду] 
*  [http://ru.wikipedia.org/wiki/UTF-8 Заметка Википедии по UTF-8] 
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Символы vs байты] 

== Известные источники проблем ==

=== Системные конфигурационные файлы (в /etc) ===

Большинство системных конфигурационных файлов, например {{Path|/etc/fstab}}, не поддерживают UTF-8. Рекомендуется придерживаться набора символов ASCII при работе с этими файлами. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Thomas Martin
* Alexander Simonov
* Shyam Mani
* nightmorph
