<languages />

Ce guide vous explique comment utiliser <code>prelink</code> dans Portage 2.0.46 et postérieur.

== Introduction ==

=== Qu'est-ce que Prelink et que peut-il faire pour moi ? ===

La plupart des applications utilisent des bibliothèques partagées (''shared libraries'' ). Ces bibliothèques partagées ont besoin d'être chargées en mémoire lors de l'exécution de l'application et les références aux différents symboles doivent être résolues. Pour la plupart des petits programmes, cette liaison dynamique est très rapide. Mais pour les programmes écrits en C++ qui ont beaucoup de dépendances, la liaison dynamique peut prendre un temps considérable. 

Sur la plupart des systèmes, les bibliothèques ne changent pas souvent et quand un programme est en cours d'exécution l'opération de liaison est toujours la même. Prelink utilise ceci à son avantage en établissant la liaison et en l'enregistrant dans l'exécutable, dans les fait en le pré-liant. 

Le pré-lien peut raccourcir le temps de démarrage des applications. Par exemple, le temps de chargement d'un programme KDE normal peut être réduit de plus de 50%. La seule opération de maintenance nécessaire est de ré-exécuter <code>prelink</code> chaque fois qu'une bibliothèque est mise à jour pour un exécutable pré-lié. 

{{Warning|  Prelink ne fonctionne pas avec la version sécurisée Hardened de Gentoo parce que les deux systèmes essaient de modifier les adresses des bibliothèques partagées. L'option -R de prelink offre un certain niveau de sécurité en utilisant des adresses aléatoires.}}

=== Résumé ===

* La pré-liaison s'effectue via un programme appelé, de manière originale, . Il modifie le binaire afin de lui permettre de démarrer plus rapidement.
* Si une application pré-liée voit une de ses bibliothèques modifiée (mise à jour), alors il faut relancer <code>prelink</code> sur l'application, dans le cas contraire vous n'obtiendrez aucune amélioration de vitesse. En fait, à chaque fois que vous mettez à jour, via Portage,  un paquet  qui met à jour des bibliothèques, vous devez relancer <code>prelink</code> sur ces bibliothèques.
* Les modifications effectuées sur le binaire sont complètement réversibles. <code>prelink</code> dispose d'une fonction d'annulation.
* Les versions récentes de Portage peuvent gérer, via <code>prelink</code>, les changements de ''MD5sum'' et ''mtime'' des binaires.
* Il n'est pas nécessaire de définir FEATURES="prelink" dans le fichier {{Path|make.conf}}, car Portage utilise <code>prelink</code> automatiquement quand le programme <code>prelink</code> est installé sur votre système.

== Configurer Prelink ==

=== Installer les programmes ===

Vous devez d'abord installer le programme <code>prelink</code>. Le processus ''emerge'' vérifie automatiquement que votre système peut utiliser <code>prelink</code> en toute sécurité. 

{{Emerge|prelink}}

A number of people get errors in emerging prelink because of the failed tests. The tests were put in for safety reasons, prelink's behavior is undefined if you disable them. The emerge errors are usually only dependent on the core packages; binutils, gcc, and glibc. Try re-emerging those packages in that order. 

{{Note|Tip: If you get an error try compiling and testing <code>prelink</code> yourself ( <code>./configure</code> ; <code>make</code> ; <code>make check</code> ). On a failure you can view the *.log files in the testsuite directory. They may provide you with some useful clues.}}

If you have a set of steps that reproduces the emerge error on another system please check [http://bugzilla.gentoo.org Bugzilla] and create a bug report if it has not already been reported. 

=== Preparing your System ===

Also make sure that you do ''not'' have -fPIC set in your CFLAGS/CXXFLAGS. If you do, you will need to rebuild your entire system without. 

=== Configuration ===

Running <code>env-update</code> will generate the {{Path|/etc/prelink.conf}} file that tells {{Path|prelink}} which files to prelink. 

{{RootCmd|env-update}}

Unfortunately you cannot prelink files that were compiled by old versions of binutils. Most of these applications come from pre-compiled, binary only packages which are installed in {{Path|/opt}} . Making the following file will tell prelink not to attempt to prelink them. 

{{Code|/etc/env.d/60prelink|<pre>
PRELINK_PATH_MASK="/opt"
</pre>
}}

{{Note|You can add more or less directories to the colon separated list.}}

== Prelinking ==

=== Prelink Usage ===

I use the following command to prelink all the binaries in the directories given by {{Path|/etc/prelink.conf}} . 

{{RootCmd|prelink -amR}}

{{Warning|It has been observed that if you are low on disk space and you prelink your entire system then there is a possibility that your binaries may be truncated. The result being a b0rked system. Use the <code>file</code> or <code>readelf</code> command to check the state of a binary file. Alternatively, check the amount of free space on your harddrive ahead of time with <code>df -h</code> .}}

{| class="wikitable" style="text-align: left;" 
|- 
! The options explained:
|- 
! -a
| "All": prelinks all the binaries
|- 
! -m
| Conserve the virtual memory space. This is needed if you have a lot of libraries that need to be prelinked.
|- 
! -R
| Random -- randomize the address ordering, this enhances security against buffer overflows.
|-
|}

{{Note|For more options and details see <code>man prelink</code> .}}

=== Prelink Cron Job ===

<code>sys-devel/prelink-20060213</code> and later install a cron job in {{Path|/etc/cron.daily/prelink}} . To enable it, edit the configuration file {{Path|/etc/conf.d/prelink}} . This will run prelink daily in the background, as needed, saving you running the command manually. 

=== Speeding Up KDE After Prelinking ===

KDE's loading time can be greatly reduced after prelinking. If you inform KDE that it has been prelinked it will disable the loading of <code>kdeinit</code> (as it isn't required anymore) which speeds up KDE even more. 

Set <code>KDE_IS_PRELINKED=1</code> in {{Path|/etc/env.d/*kdepaths*}} to inform KDE about the prelinking.

=== Removing prelink ===

If you ever change your mind about prelinking, before you unmerge prelink, you'll first need to remove the prelink cronjob from {{Path|/etc/cron.daily}} and {{Path|/etc/conf.d/prelink}} . Next, you'll have to remove prelinking from all binaries: 

{{RootCmd|prelink -au}}

Finally, unmerge the <code>prelink</code> package itself: 

{{RootCmd|emerge -c prelink}}

== Known Problems and Fixes ==

=== "Cannot prelink against non-PIC shared library" ===

The cause of this problem is from badly compiled shared libraries that were compiled without the -fPIC gcc option for all their object files. 

Here are the libraries that haven't been fixed or cannot be fixed: 

* The libraries in the wine package, including winex. Prelinking wouldn't speed up MS Windows executables anyway.
* The library in media-video/mjpegtools, {{Path|/usr/lib/liblavfile-1.6.so.0}} .
* Nvidia OpenGl libraries, {{Path|/usr/lib/opengl/nvidia/lib/libGL.so.*}} . Due to performance reasons they were compiled without PIC support.

If your problem library was not listed please report it with, preferably, a patch to add <code>-fPIC</code> to the relevant CFLAGS. 

=== When I prelink my system some static binaries don't work anymore ===

Where glibc is concerned, there is no such thing as a 100% static binary. If you statically compile a binary with glibc, it may still depend on other system files. Below is an explanation by Dick Howell, 

"I suppose the idea is that everything will be in the downloaded file, so nothing depends on the local libraries on the target system. Unfortunately with Linux, and I think anything else using GLIBC, this still isn't quite true. There's this "libnss" (name service switch, some people seem to call it network security system) which provides functions for accessing various databases for authentication, network information, and other things. It's supposed to make application programs independent of the separately configured actual network environment of the machine. A nice idea, but changes to GLIBC can lead to problems loading it. And you can't statically link "libnss", since it is configured for each machine individually. The problem comes, I think, mainly from statically linking other GLIBC libraries, notably "libpthread", "libm", and "libc", from which come incompatible calls to "libnss" functions." 

=== Prelink aborts with "prelink: dso.c:306: fdopen_dso: Assertion `j == k' failed." ===

This a known problem, kindly diagnosed [http://bugs.gentoo.org/show_bug.cgi?id=13878 here] . Prelink cannot cope with UPX-compressed executables. As of prelink-20021213 there is no fix except to hide the executables while you are prelinking. See the section above for an easy way to do this. 

=== I use grsecurity and it seems that prelinking doesn't work. ===

In order to prelink on a system with grsecurity using a randomized mmap() base, it is necessary to turn "randomized mmap() base" OFF for {{Path|/lib/ld-2.3.*.so}} . This can be done with the <code>chpax</code> utility, but it must be done when the file is not in use (f.i. boot from a rescue CD). 

=== Prelink fails with error "prelink: Can't walk directory tree XXXX: Too many levels of symbolic links" ===

Your symlinks are nested too deeply. This happens when a symlink points to itself. For example, {{Path|/usr/lib/lib -> lib}} is the most common. To fix this, you can find the symlink manually or use the utility provided by the <code>symlinks</code> package: 

{{RootCmd|emerge symlinks
|symlinks -drv /}}

More details can be found at [http://bugs.gentoo.org/show_bug.cgi?id=82117 Bugzilla] and this [http://forums.gentoo.org/viewtopic-t-458144-highlight-prelink.html forum post] . 

== Conclusion ==

Prelinking can drastically speed up the start up times for a number of large applications. Support is built into Portage. Prelinking is also safe as you can always undo the prelinking for any binary if you come across any problems. Just remember that when you update glibc or other libraries that you prelinked with, you need to rerun {{Path|prelink}} ! In short good luck! 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:


* Stefan Jones
* John P. Davis
* Jorge Paulo
* Sven Vermeulen
* Erwin
* nightmorph
