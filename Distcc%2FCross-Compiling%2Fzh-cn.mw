<languages />


{{Metadata|abstract=本文向你展示如何配置distcc在不同的处理器架构之间进行交叉编译。}}

本文向你展示如何配置distcc在不同的处理器架构之间进行交叉编译。

== 使用distcc进行交叉编译 ==

=== 介绍 ===

<code>distcc</code>是一个工具，能让你在网络中的多台机器共同编译软件。只要在网络中的机器使用相同的工具链为相同的处理器架构编译，就不需要特殊的<code>distcc</code>配置。但是如果你想用不同的机器为不同的架构进行编译呢？这篇指南将向你展示如何配置<code>distcc</code>来为不同的架构进行编译。 

=== 安装必要的工具 ===

首先，你需要在所有的参与编译的机器上安装<code>crossdev</code>。<code>crossdev</code>是一个能够让简化跨架构工具链编译的工具。最初由Joshua Kinard编写，后来Mike Frysinger进行了完全的重写。它的使用非常的直观：<code>crossdev -t sparc</code>将为Sparc架构编译完整的交叉工具链。这包含binutils，gcc，glibc和linux-headers。如果你需要帮助，尝试运行<code>crossdev --help</code>。很明显，你要要在所有帮助编译的机器上安装合适的交叉工具链。

If you want to fine tune the cross-toolchain, here is a script that will produce a command line with the exact versions of the cross development packages to be built on the helper boxes (the script is to be run on the target box).

{{Code|Script to fine-tune cross development tools|<pre>
#! /bin/bash
A="sys-devel/binutils" ; B=`equery l $A` ; BINUTILS_VER=`echo $B | cut -d- -f3-`
A=`/usr/bin/gcc-config -c` ; B=`echo $A | cut -d- -f5` ; GCC_VER=`equery l sys-devel/gcc | grep $B | cut -d- -f3-`
KERNEL_VER=`uname -r | sed s/-gentoo//`
A="sys-libs/glibc" ; B=`equery l $A` ; LIBC_VER=`echo $B | cut -d- -f3-`
echo "crossdev --b =$BINUTILS_VER --g =$GCC_VER --k =$KERNEL_VER --l =$LIBC_VER -t `uname -m`"
</pre>}}

Next, you will need to emerge <code>distcc</code> on all the machines that will be involved in the process. This includes the box that will run emerge and the boxes with the cross-compilers. Please see the [[Distcc|Gentoo Distcc Documentation]] for more information on setting up and using <code>distcc</code>.

=== Arch-specific notes ===

==== Intel x86 subarchitectures ====

If you are cross-compiling between different subarchitectures for Intel x86 (e.g. i586 and i686), you must still build a full cross-toolchain for the desired CHOST, or else the compilation will fail. This is because i586 and i686 are actually different CHOSTs, despite the fact that they are both considered "x86." Please keep this in mind when you build your cross-toolchains. For example, if the target box is i586, this means that you must build i586 cross-toolchains on your i686 helper boxes. 

==== SPARC ====

使用<code>crossdev -t sparc</code>也许会失败，伴随如下错误：

{{Code|运行crossdev -t sparc时出现的错误|<pre>
linker with -z relro support required
support for the tls_model attribute is required
this configuration requires -mlong-double-128 support
</pre>}}

如果发生上述错误，尝试使用下面的命令：

{{Cmd|crossdev --lenv "CC{{=}}sparc-unknown-linux-gnu-gcc" -t sparc-unknown-linux-gnu}}

=== 配置distcc以便正确的交叉编译 ===

使用默认的distcc配置，交叉编译“不”会正常工作。这是因为很多编译仅仅调用<code>gcc</code>而不是编译器的全名（例如<code>sparc-unknown-linux-gnu-gcc</code>）。当这一编译被分发到帮助交叉编译的机器上时，原生的编译器被调用，而非你新安装的交叉编译器。 

Fortunately, there is a workaround for this little problem. All it takes is a wrapper script and a few symlinks on the box that will be running <code>emerge</code>. We'll use a Sparc box as an example. Wherever you see <code>sparc-unknown-linux-gnu</code> below, you will want to insert your own CHOST (<code>x86_64-pc-linux-gnu</code> for an AMD64 box, for example). When you first emerge distcc, the {{Path|/usr/lib/distcc/bin}} directory looks like this: 

{{Note/zh-cn|下面的操作只需要在运行emerge的机器上执行，不要在帮助交叉编译的机器上运行。}}

{{RootCmd|cd /usr/lib/distcc/bin
|ls -l|output=<pre>
total 0
lrwxrwxrwx  1 root root 15 Dec 23 20:13 c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 cc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 gcc -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Dec 23 20:13 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
</pre>
}}

这里你需要做： 

{{RootCmd|rm c++ g++ gcc cc}}

然后，你要在这台机器上创建一个新的脚本。打开你喜欢的文本编辑器，创建一个文件，内容如下。然后保存到{{Path|sparc-unknown-linux-gnu-wrapper}}。记住替换CHOST（这里是<code>sparc-unknown-linux-gnu</code>）成你要运行emerge的机器的实际的CHOST。 

{{Code|The new wrapper script|<pre>
#!/bin/bash
exec /usr/lib/distcc/bin/sparc-unknown-linux-gnu-g${0:$[-2]} "$@"
</pre>
}}

接下来，将此脚本设置为可执行，并创建适当的符号链接： 

{{RootCmd|chmod a+x sparc-unknown-linux-gnu-wrapper
|ln -s sparc-unknown-linux-gnu-wrapper cc
|ln -s sparc-unknown-linux-gnu-wrapper gcc
|ln -s sparc-unknown-linux-gnu-wrapper g++
|ln -s sparc-unknown-linux-gnu-wrapper c++}}

当你完成以后，{{Path|/usr/lib/distcc/bin}}看起来像这样： 

{{RootCmd|ls -l|output=<pre>
total 4
lrwxrwxrwx  1 root root 25 Jan 18 14:20 c++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 cc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 g++ -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 25 Jan 18 14:20 gcc -> sparc-unknown-linux-gnu-wrapper
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-c++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Nov 21 10:42 sparc-unknown-linux-gnu-g++ -> /usr/bin/distcc
lrwxrwxrwx  1 root root 15 Jul 27 10:52 sparc-unknown-linux-gnu-gcc -> /usr/bin/distcc
-rwxr-xr-x  1 root root 70 Jan 18 14:20 sparc-unknown-linux-gnu-wrapper
</pre>
}}

Next we want to make sure that these wrappers stay available after upgrading the distcc package as it will overwrite the symbolic links. We can do this through a {{Path|/etc/portage/bashrc}} file that looks like so:

{{Code|/etc/portage/bashrc|<pre>
case ${CATEGORY}/${PN} in
	sys-devel/distcc)
		# Hey man, how come that CONFIG PROTECT don't work?
		if [ "${EBUILD_PHASE}" == "postinst" ] || [ "${EBUILD_PHASE}" == "postrm" ];
		then
			cd /usr/lib/distcc/bin
			rm cc c++ gcc g++
			ln -s sparc-unknown-linux-gnu-wrapper cc
			ln -s sparc-unknown-linux-gnu-wrapper c++
			ln -s sparc-unknown-linux-gnu-wrapper gcc
			ln -s sparc-unknown-linux-gnu-wrapper g++
		fi
	;;
esac</pre>
}}

恭喜，你已经有一个可以工作的distcc配置了（希望如此）。

=== 这是如何工作的 ===

当<code>distcc</code>被调用的时候，它会检查自己是以何种方式被调用的（例如<code>i686-pc-linux-gnu-gcc</code>，<code>sparc-unknown-linux-gnu-g++</code>等等）。当distcc把编译工作分发到帮助交叉编译的机器上的时候，它会把调用方式一起分发。在帮助交叉编译的机器上，distcc的守护进程会去寻找有相同名字的程序。如果它看到的仅仅是<code>gcc</code>，它就会去找<code>gcc</code>，如果帮助交叉编译的机器架构跟运行<code>emerge</code>的机器不一致，distcc的守护进程找到的gcc很可能是这台机器上的原生的的编译器。如果发送的是编译器的“全名”（例如<code>sparc-unknown-linux-gnu-gcc</code>），就不会出现混淆。

== 感谢 ==

感谢下面的作者和编辑对这篇指南的贡献：

* Andrew Gaffney
* Joshua Saddler
