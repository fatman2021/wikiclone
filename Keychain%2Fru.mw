<languages />

В этом документе описано использование общих ключей SSH вместе с программой для управления ими. Предполагается базовое знание криптографии с открытым ключом.

== Основы ==

=== Рассматриваемая проблема ===

Итак, Вы обладаете всеми эти прекрасными компьютерами с Gentoo, с запущенным <code>sshd</code>, но Вам немного неудобно печатать все эти пароли для входа, верно? Или, может быть, Вы имеете сценарий или cron-задачу, которым необходим удобный способ использования ssh соединения. Так или иначе, у этой проблемы есть решение, и оно начинается с аутентификации с открытым ключом. 

=== Как работает аутентификация с открытым ключом? ===

Предположим, у нас есть клиент, который хочет соединиться с сервером через sshd. Клиент сначала генерирует пару ключей и пересылает открытый ключ на сервер. Затем, когда бы клиент ни пытался соединиться с сервером, сервер отправляет послание, которое зашифровано с помощью открытого ключа. Только обладатель соответствующего закрытого ключа (т.е. клиент) способен его расшифровать, так что, как Вы уже догадались, правильный ответ ведет к успешной аутентификации. 

== Как использовать аутентификацию с открытым ключом ==

=== Генерация ключевой пары ===

Первым шагом является создание Вашей пары ключей. Для того, чтобы это сделать, мы будем использовать команду <code>ssh-keygen</code>, как то: 

{{Cmd|ssh-keygen -t dsa}}

Просто примите значения по умолчанию, и удостоверьтесь, что Вы ввели надежную парольную фразу.

{{Warning/ru|Убедитесь, что Вы выбрали надежную парольную фразу, особенно если этот ключ используется для учетной записи администратора!}}

Теперь у Вас должен быть закрытый ключ в {{Path|~/.ssh/id_dsa}} и открытый ключ в {{Path|~/.ssh/id_dsa.pub}} . Мы готовы скопировать открытый ключ на удаленный компьютер. 

=== Подготовка сервера ===

Мы скопируем файл {{Path|~/.ssh/id_dsa.pub}} на сервер, на котором запущен sshd. Мы также добавим его в файл {{Path|~/.ssh/authorized_keys}}, который принадлежит соединяющемуся пользователю на этом сервере. Здесь приведен пример того, как это сделать если Вы уже обладаете доступом к серверу по ssh: 

{{Cmd|scp ~/.ssh/id_dsa.pub server_user@server:~/myhost.pub
|ssh server_user@server "cat ~/myhost.pub &gt;&gt; ~/.ssh/authorized_keys"
|ssh server_user@server "cat ~/.ssh/authorized_keys"}}

Результат, показанный на последней строке, должен отобразить содержимое файла {{Path|~/.ssh/authorized_keys}}. Убедитесь, что он выглядит правильно. 

=== Тестирование установки ===

В теории, если все прошло правильно, и ssh-демон на сервере это позволяет, сейчас мы должны быть способны получить доступ к серверу по ssh без пароля. Мы все еще должны расшифровать закрытый ключ на клиенте паролем, который мы использовали ранее, но он не должен быть перепутан с паролем от учетной записи пользователя на этом сервере. 

{{Cmd|ssh server_user@server}}

Надеемся, у Вас была запрошена парольная фраза для id_dsa, и Вы смогли получить доступ к серверу по ssh как server_user. Если это не так, войдите как server_user, и проверьте содержимое {{Path|~/.ssh/authorized_keys}} для того чтобы убедиться, кто каждая запись находится на отдельной строке. Вы также можете проверить конфигурацию sshd для того, чтобы убедиться что предпочитается использование авторизации с открытым ключом, когда это доступно. 

В этом месте, Вы возможно подумаете: "Какая разница, я просто заменил один пароль другим?!" Успокойтесь, в следующем разделе Вам будет продемонстрировано точно, как мы можем использовать это, чтобы сохранить наше драгоценное время. 

== Как сделать аутентификацию с открытым ключом удобной ==

=== Обычное управление ключами с помощью ssh-agent ===

Если Вы подробно следуете руководству, Вы возможно уже подумали, как было бы хорошо если бы мы смогли как-нибудь расшифровать наши закрытые ключи/ключ один раз, и получить возможность свободно соединяться по ssh, без каких-либо паролей. Вам повезло, это как раз то, для чего предназначена программа <code>ssh-agent</code> . 

Программа <code>ssh-agent</code> обычно запускается вначале вашей X-сессии, или из сценария запуска оболочки, например {{Path|~/.bash_profile}} . Она работает путем создания доменного сокета Unix и регистрации подходящих переменных среды, так чтобы все последующие приложения могли воспользоваться ее сервисами, подсоединяясь к этому сокету. Очевидно, имеет смысл запускать ее только в родительском процессе Вашей X-сессии, если Вы хотите использовать набор расшифрованных закрытых ключей во всех последующих X-приложениях. 

{{Cmd|eval `ssh-agent`}}

{{Note/ru|Этот ssh-agent будет хранить ключи расшифрованными, пока Вы его не завершите. Если Вы хотите установить время существования ключей, используйте параметр -t, как описано в <code>man ssh-agent</code> .}}

При запуске, ssh-agent должен сообщить Вам PID запущенного ssh-agent, и также установить несколько переменных среды, а именно <code>SSH_AUTH_SOCK</code> и <code>SSH_AGENT_PID</code> . Он также должен автоматически добавить {{Path|~/.ssh/id_dsa}} к своему набору и запросить соответствующую парольную фразу. Если Вы имеете другие закрытые ключи, Вы можете пожелать добавить их к запущенному ssh-agent, для этого Вы можете использовать команду <code>ssh-add</code>, как то: 

{{Cmd|ssh-add somekeyfile}}

А теперь начинается магия. Так как у Вас уже есть расшифрованный закрытый ключ, Вы можете получить доступ к серверу по ssh без ввода какого-либо пароля: 

{{Cmd|ssh server}}

Было бы неплохо узнать как закрыть ssh-agent, в случае если вам это потребуется, правда? 

{{Cmd|ssh-agent -k}}

{{Note/ru|Если Вы испытывали проблемы с запуском ssh-agent, он все еще мог работать. Вы можете завершить его работу, как и в случае с любым другим процессом, запустив команду <code>killall ssh-agent</code> .}}

Если Вы хотите еще больше удобства в работе с ssh-agent, продолжайте читать следующую главу, описывающую использование keychain. Убедитесь, что Вы завершили работающий ssh-agent, как в примере выше, если Вы решили это сделать.

=== Выжимание последней капли удобства из ssh-agent ===

Программа keychain позволит Вам использовать ssh-agent заново между входами в систему, и, дополнительно, запрашивать парольные фразы каждый раз, когда входит пользователь. Перед тем, как опередить самих себя, давайте сначала ее установим. 

{{Emerge|keychain}}

Предполагая, что установка была успешной, мы теперь можем использовать программу keychain свободно. Добавьте следующее в Ваш {{Path|~/.bash_profile}}, для того, чтобы обеспечить к ней доступ: 

{{Code|Обеспечение доступа к keychain в .bash_profile|<pre>
keychain ~/.ssh/id_dsa
. ~/.keychain/$HOSTNAME-sh
. ~/.keychain/$HOSTNAME-sh-gpg
</pre>
}}

{{Note/ru|Вы можете добавить большее количество закрытых ключей в командной строке, по Вашему желанию. Также, если Вы хотите запрашивать парольную фразу каждый раз, когда Вы открываете оболочку, добавьте параметр --clear.}}

{{Note/ru|Если Вы не используете оболочку bash, проверьте раздел '''EXAMPLES''' <code>man keychain</code> для поиска примеров использования в других оболочках. Основной идеей является запуск этих команд каждый раз, когда Вы пользуетесь оболочкой.}}

Давайте это протестируем. Сперва, убедитесь, что мы завершили ssh-agent из предыдущего раздела, затем откройте новую оболочку, обычно простым входом, или открытием нового эмулятора терминала. У Вас должны быть запрошены парольные фразы для каждого ключа, который Вы указали в командной строке. Все оболочки открытые после этого, должны использовать ssh-agent заново, позволяя Вам открывать ssh-соединения без пароля снова и снова. 

=== Использование keychain с KDE ===

Если Вы являетесь пользователем KDE, вместо использования {{Path|~/.bash_profile}} , Вы можете позволить KDE управлять программой ssh-agent за Вас. Для того, чтобы это сделать, Вам необходимо отредактировать файл {{Path|/etc/kde/agent-startup.sh}} , который читается во время запуска KDE, и {{Path|/etc/kde/shutdown/agent-shutdown.sh}} , который запускается во время закрытия KDE. Здесь показано, как Вы можете отредактировать эти файлы: 

{{Code|Редактирование /etc/kde/agent-startup.sh|<pre>
if [ -x /usr/bin/ssh-agent ]; then
  eval "$(/usr/bin/ssh-agent -s)"
fi
</pre>
}}

{{Code|Редактирование /etc/kde/shutdown/agent-shutdown.sh|<pre>
if [ -n "${SSH_AGENT_PID}" ]; then
  eval "$(ssh-agent -k)"
fi
</pre>
}}

Теперь, все, что Вам необходимо сделать, это запустить эмулятор терминала по Вашему вкусу, например Konsole, и загрузить ключи, которые Вы бы хотели использовать. Например: 

{{Cmd|keychain ~/.ssh/id_dsa}}

Ваши ключи будут запомнены до окончания Вашей KDE-сессии или закрытия ssh-agent вручную. 

== Завершающие примечания ==

=== Соображения безопасности ===

Конечно же, использование ssh-agent может немного ухудшить безопасность Вашей системы. Если бы другой пользователь использовал Вашу оболочку пока Вы были в ванной, он смог бы войти на все ваши серверы без пароля. В результате, это является риском для серверов, к которым вы подсоединяетесь, и Вы должны быть уверены в том, что Вы проконсультировались с местной политикой безопасности. Если Вы этим пользуетесь, будьте уверены в том, что Вы приняли необходимые меры длы обеспечения безопасности Ваших сессий. 

=== Устранение проблем ===

Большинство из описанного должно работать без проблем, но если Вы с ними столкнулись, Вы определенно захотите знать несколько полезных вещей. 

* Если вы не можете соединиться без ssh-agent, рассмотрите использование ssh с аргументами -vvv, чтобы узнать что произошло. Иногда, сервер не настроен для использования аутентификации с открытым ключом, иногда он настроен на запрашивание локальных паролей в любом случае! Если это как раз тот самый случай, Вы могли бы использовать с ssh параметр -o, или изменить файл конфигурации sshd_config на сервере.
* Если у Вас проблемы с ssh-agent или keychain, это может быть потому что Вы не используете оболочку, которая понимает используемые ими команды. Проконсультируйтесь с man-страницами для программ ssh-agent и keychain для поиска подробностей по работе с другими оболочками.
* Вы также можете посетить [https://github.com/funtoo/keychain keychain homepage] для поиска других советов по использованию.

== Благодарности ==

Мы хотели бы поблагодарить следующих авторов и редакторов за их вклад в это руководство:


* Eric Brown
* Marcelo Goes
* nightmorph

[[Category:Server and Security]]
