<languages />

UTF-8 est un encodage des caractères de longueur variable qui, dans ce cas, signifie qu'il utilise 1 à 4 octets par symbole. Le premier octet sert à encoder les caractères ASCII, donnant ainsi au jeu de caractères une totale compatibilité avec ASCII. UTF-8 signifie que les caractères ASCII et latins sont interchangeables moyennant un petit accroissement de la taille des données, parce que seul le premier chiffre binaire est utilisé. Les utilisateurs d'alphabets de l'est asiatique, comme les japonais, à qui ont a attribué une plage plus élevée d'octets sont insatisfaits, car cela conduit à plus de 50% de redondance dans leurs données. 

== Encodage des caractères ==

=== Qu'est-ce que l'encodage des caractères ? ===

Les ordinateurs ne comprennent pas les textes eux-mêmes. Au lieu de cela, chaque caractère est représenté par un nombre. Traditionnellement, chaque jeu de nombres utilisé pour représenter les alphabets et les caractères (connu sous le nom de système de codage, encodage ou jeu de caractères) était limité en taille à cause de la limitation même du matériel constituant les ordinateurs. 

=== L'histoire de l'encodage des caractères ===

Le plus courant (ou du moins le plus largement accepté) des jeux de caractères est l''''ASCII''' (American Standard Code for Information Interchange). Il est largement reconnu que l'ASCII est la norme  logicielle qui a connu le plus grand succès de tous les temps. L'ASCII moderne a été normalisé en 1986  (ANSI X3.4, RFC 20, ISO/IEC 646:1991, ECMA-6) par l'American National Standards Institute. 

ASCII, a strictement parler, est encodé sur 7 chiffres binaires, ce qui signifie qu'il utilise des motifs de chiffres représentables avec 7 chiffres binaires. Ce qui correspond à la plage 0 à 127 en décimal. Ceci inclut 32 caractères de contrôle non visualisables, en majorité entre 0 et 31, auxquels s'ajoute le caractère de contrôle final, DEL ou delete, dont la représentation est 127. Tous les caractères entre 32 et 126 inclus, sont visualisables : l'espace, les marques de ponctuation, les lettres latines et les chiffres. 

Le huitième bit en ASCII était à l'origine utilisé comme bit de parité pour la détection d'erreurs. Si cela n'est pas souhaité, on peut le laisser à 0. Ceci signifie que, avec l'ASCII, chaque caractère est représenté par un seul octet. 

Bien que l'ASCII soit suffisant pour communiquer en anglais moderne, dans d'autres langues européens qui comprennent des caractères accentués, les choses ne sont pas aussi simples. Les normes ISO 8859 ont été développées pour satisfaire ces besoins. Elles sont rétro-compatibles avec l'ASCII, mais au lieu de laisser le huitième chiffre binaire à 0, elles l'utilisent pour former un autre ensemble de 127 caractères dans chacun des encodages. Les limitations des normes ISO 8859 sont apparues très vite, et il y a aujourd'hui 15 variantes de la norme ISO 8859 (8859-1 à 8859-15). En dehors de la plage compatible avec l'ASCII, il y a souvent des conflits entre les lettres représentées par chacun des octets. Pour compliquer encore l'interopérabilité entre versions, Windows-1252 est utilisée à leur place dans certaines versions de Microsoft Windows pour les langues européennes. Il s'agit d'un jeu étendu de ISO-8859-1, cependant il en différe de plusieurs façons. Tous ces jeux restent néanmoins compatibles avec ASCII. 

Le développement nécessaire d'encodage mono-octet pour des alphabets non latins, tels que EUC (Extended Unix Coding) qui est utilisé pour le Japonais et le Coréen (et dans une moindre mesure pour le Chinois) a créé encore plus de confusion, tandis que d'autres systèmes d'exploitation utilisaient des jeux de caractères différents pour les mêmes langues, par exemple, Shift-JIS et ISO-2022-JP. Les utilisateurs désireux d'afficher des glyphes cyrilliques avaient à choisir entre KOI8-R pour le Russe et le Bulgare ou KOI8-U pour l'Ukrainien, aussi bien que parmi les autres encodages cyrilliques comme le peu prisé ISO 8859-5 et le plus connu Windows-1251. Tous ces jeux de caractères rompaient la compatibilité avec ASCII (quoi que le jeu KOI8 place les caractères cyrilliques dans l'ordre latin, de manière telle que si le huitième chiffre binaire est retiré, le texte est déchiffrable sur un terminal ASCII via une translittération à casse inversée.) 

Ceci a conduit à la confusion, et aussi à une presque totale incapacité à communiquer dans plusieurs langues, en particulier à travers des alphabets différents. C'est là qu' Unicode entre en scène. 

=== Qu'est-ce qu'Unicode ? ===

La norme Unicode jette aux orties la limite traditionnelle d'un octet pour les jeux de caractères. Elle  utilise 17 ''plans'' de 65.536 points de code pour décrire un maximum de 1.114.112 caractères. Comme le premier plan, aussi connu sous le nom de ''Basic Multilingual Plane (Plan Multilingue de Base)'' ou BMP, contient presque tout ce dont vous aurez jamais besoin, beaucoup ont fait la supposition fausse que l'Unicode était un jeu de caractères encodé sur 16 chiffres binaires. 

Unicode a été cartographié de différentes manières, mais les deux plus courantes sont '''UTF''' (Unicode Transformation Format pour Format de transformation d'Unicode) et '''UCS''' (Universal Character Set pour Jeu de caractères universel). Le nombre après UTF indique le nombre de chiffres binaires dans chacun des éléments, tandis que le nombre après UCS indique le nombre d'octets. UTF-8 est devenu le moyen le plus répandu pour l'échange de text Unicode en raison de sa nature 8 chiffres binaires pure, et fait l'objet de ce document. 

=== Que peut faire UTF-8 pour vous ? ===

UTF-8 vous permet de travailler dans un environnement multilingue conforme aux normes et reconnu internationalement, avec une redondance des données comparativement faible. UTF-8 est le moyen privilégié pour transmettre les caractères non ASCII sur Internet, via des courriels, l'IRC ou presque n'importe quel autre médium. En dépit de cela, beaucoup de gens considèrent la communication en ligne en UTF-8 comme abusive. Il est toujours bon d'être conscient de cela sur certains canaux, listes de diffusion ou groupes Usenet avant d'employer des caractères non ASCII en UTF-8. 

== Installer l' UTF-8 sur Gentoo Linux ==

=== Trouver ou créer des locales UTF-8  ===

Maintenant que vous comprenez les principes d'Unicode, vous êtes prêt à utiliser UTF-8 sur votre système. 

Le prérequis pour UTF-8 est d'avoir une version de glibc installée qui assure la prise en charge de la langue nationale. Le moyen recommandé pour réaliser cela, est le fichier {{Path|/etc/locale.gen}}. C'est cependant au-delà du champ de ce document d'expliquer l'utilisation de ce fichier. Ceci est expliqué dans le [https://wiki.gentoo.org/wiki/Localization/HOWTO Gentoo Localization Guide] . 

Ensuite, vous devez décider si une locale UTF-8 est déjà disponible pour votre langue, ou si vous devez en créer une. 

{{Cmd|locale -a {{!}} grep 'en_GB'|output=<pre>
en_GB
en_GB.UTF-8
</pre>
}}

De la sortie de cette commande, vous devez prendre le résultat avec un suffixe similaire à  <code>.UTF-8</code>. Si vous ne trouvez aucun résultat avec un suffixe similaire à  <code>.UTF-8</code>, vous devez créez une locale UTF-8 compatible. 


{{Note|N'exécutez le code suivant que si vous n'avez pas une locale UTF-8 disponible pour votre langue.}}

Remplacez "en_GB" avec le code de locale que vous souhaitez :
{{RootCmd|localedef -i en_GB -f UTF-8 en_GB.UTF-8}}

Une autre façon d'inclure une locale UTF-8 est de l'ajouter au fichier {{Path|/etc/locale.gen}} et de générer les locales nécessaire avec la commande <code>locale-gen</code>. 

{{Code|Line in /etc/locale.gen|<pre>
en_GB.UTF-8 UTF-8
</pre>
}}

=== Définir la Locale ===

Il y a une variable d'environnement qui doit être définie de manière à ce que le système utilise vos nouvelles locales UTF-8 : <code>LC_CTYPE</code> (ou, en option, <code>LANG</code>, si vous désirez changer aussi la langue). Il y a aussi différentes manières de la définir ; certains préfèrent avoir un environnement UTF-8 pour un utilisateur donné, auquel cas il la définissent dans leur fichier  {{Path|~/.profile}} (s'ils utilisent <code>/bin/sh</code> ), {{Path|~/.bash_profile}} ou {{Path|~/.bashrc}} (s'ils utilisent <code>/bin/bash</code> ). Une information complémentaire et de bonnes pratiques sont disponibles dans notre  [https://wiki.gentoo.org/wiki/Localization/HOWTO Localization Guide] . 

D'autres préfèrent la définir globalement. Une circonstance particulière où nous recommandons fortement de procéder de cette manière, c'est quand {{Path|/etc/init.d/xdm}} est utilisé, parce que ce script d'initialisation lance le gestionnaire d'écran et le bureau avant qu'aucun des scripts de démarrage mentionnés précédemment ne soit ''sourcé'', et en conséquence, avant qu'aucune des variables ne soit dans l'environnement. 

Définir la locale globalement devrait être fait en utilisant {{Path|/etc/env.d/02locale}} . Ce fichier devrait ressembler à quelque chose comme ce qui suit : 

{{Code|Demonstration /etc/env.d/02locale|<pre>
## (As always, change "en_GB.UTF-8" to your locale)
LANG="en_GB.UTF-8"
</pre>
}}

{{Note|Vous pouvez aussi remplacer  <code>LC_CTYPE</code> par <code>LANG</code> . Pour une information plus complète sur les catégories affectées par l'utilisation de  <code>LC_CTYPE</code> , lisez la [http://www.gnu.org/software/libc/manual/html_node/Locale-Categories.html#Locale-Categories GNU locale page] .}}

Ensuite l'environnement doit être mis à jour pour prendre en compte les changements. 

{{RootCmd|env-update|output=<pre>
>>> Regenerating /etc/ld.so.cache...
 * Caching service dependencies ...
</pre>}}
{{RootCmd|source /etc/profile}}

Maintenant, exécutez la commande <code>locale</code>  sans argument pour voir si vous disposez des variables correctes dans votre environnement. 

{{RootCmd|locale|output=<pre>
LANG=en_GB.UTF-8
LC_CTYPE="en_GB.UTF-8"
LC_NUMERIC="en_GB.UTF-8"
LC_TIME="en_GB.UTF-8"
LC_COLLATE="en_GB.UTF-8"
LC_MONETARY="en_GB.UTF-8"
LC_MESSAGES="en_GB.UTF-8"
LC_PAPER="en_GB.UTF-8"
LC_NAME="en_GB.UTF-8"
LC_ADDRESS="en_GB.UTF-8"
LC_TELEPHONE="en_GB.UTF-8"
LC_MEASUREMENT="en_GB.UTF-8"
LC_IDENTIFICATION="en_GB.UTF-8"
LC_ALL=
</pre>
}}

C'est tout. Vous utilisez désormais les locales UTF-8, et le prochain obstacle à franchir, c'est la configuration des applications que vous utilisez quotidiennement. 

== Prise en charge par les applications ==

Lorsque Unicode commença à prendre son essor dans le monde du logiciel, les jeux de caractères multi-octets n'étaient pas très adaptés à des langages de programmation tels que le langage C, langage dans lequel beaucoup des programmes utilisés quotidiennement sont écrits. Même encore aujourd'hui, certains programmes ne sont pas capable de prendre en charge l'UTF-8 correctement. Fort heureusement, la plupart le sont ! 

=== Noms de fichiers, NTFS, et FAT ===

Il y a plusieurs options NLS (Native Language Support) dans le menu de configuration du noyau Linux, mais il est important d'éviter la confusion ! Pour la majeure partie, la seule chose que vous avez à faire est de compiler la prise en charge de UTF-8 NLS dans votre noyau, et de changer l'option par défaut de NLS en utf8. 

{{Kernel|Kernel configuration steps for UTF-8 NLS|<pre>
File Systems -->
  Native Language Support -->
    (utf8) Default NLS Option
    <*> NLS UTF8
    ## (Also <*> other character sets that are in use in
    your FAT filesystems or Joilet CD-ROMs.)
</pre>
}}

Si vous envisagez de monter des partitions NTFS, vous avez besoin de spécifier une option <code>nls=</code> pour la commande ''mount''. Si vous envisagez de monter des partitions FAT, vous devez spécifier une option <code>codepage=</code>  pour la commande ''mount''. En option, vous pouvez aussi définir une ''page de code (codepage)'' par défaut pour FAT dans la configuration du noyau. Notez que l'option  <code>codepage</code> pour ''mount'' écrasera les réglages faits dans la configuration du noyau. 

{{Kernel|FAT settings in kernel configuration|<pre>
File Systems -->
  DOS/FAT/NT Filesystems  -->
    (437) Default codepage for fat
</pre>
}}

Vous devriez éviter de définir le <code>Default iocharset for fat</code> (jeu de caractères par défaut pour fat) à UTF-8, car ce n'est pas recommandé. Au lieu de cela, vous pouvez passer l'option utf8=true au moment de monter votre partition FAT. Pour une information plus complète, reportez-vous à la page <code>man mount</code> et à la documentation du noyau à {{Path|/usr/src/linux/Documentation/filesystems/vfat.txt}} . 

Pour changer l'encodage des noms de fichier, vous pouvez utiliser <code>app-text/convmv</code>. 

{{Emerge|app-text/convmv}}

Le format de la commande <code>convmv</code>  est le suivant :

{{RootCmd|convmv -f &lt;current-encoding&gt; -t utf-8 &lt;filename&gt;}}

Remplacez iso-8859 par le jeu de caractères à partir duquel vous effectuez la conversion :

{{RootCmd|convmv -f iso-8859-1 -t utf-8 filename}}

Pour changer le ''contenu'' de fichiers, utilisez l'utilitaire <code>iconv</code>, fournit avec <code>glibc</code>. Remplacez ''muitute iso-8859-1'' par le jeu de caractères à partir duquel vous effectuez la conversion, et vérifiez que la sortie est saine :

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename}}

Pour convertir un fichier vous devez en créer un autre :

{{RootCmd|iconv -f iso-8859-1 -t utf-8 filename &gt; newfile}}

{{Package|app-text/recode}} peut aussi être utilisé à cet effet. 

=== La console système ===

{{Important|Vous avez besoin de sys-apps/baselayout-1.11.9 ou plus récent pour disposer d' Unicode à la console.}}

Pour valider UTF-8 à la console, vous devriez éditer  {{Path|/etc/rc.conf}} et définir  <code>unicode="yes"</code>, et lire aussi les commentaires de ce fichier--il est important d'avoir une police de caractères qui dispose d'une bonne plage de caractères si vous envisagez d'utiliser Unicode largement. Pour que cela fonctionne, assurez-vous d'avoir créé la locale Unicode correctement. 

La variable <code>keymap</code> variable, définie dans {{Path|/etc/conf.d/keymaps}} , devrait spécifier une carte de clavier Unicode. 

{{Code|Example /etc/conf.d/keymaps snippet|<pre>
## (Change "uk" to your local layout)
keymap="uk"
</pre>
}}

=== Ncurses et Slang ===

{{Note|Veuillez ignorer toute référence à Slang dans cette section si vous ne l'avez pas installé ou si vous ne l'utilisez pas.}}

Il est sage d'ajouter <code>unicode</code> aux options globales de votre variable USE dans le fichier {{Path|/etc/portage/make.conf}}, et de réinstaller <code>sys-libs/ncurses</code> et <code>sys-libs/slang</code> si c'est approprié. Portage le fera automatiquement si vous mettez votre système à jour : 

{{RootCmd|emerge --update --deep --newuse world}}

Il vous faut également recompiler les paquets qui possèdent un lien vers ceux-là, maintenant que les changements de la variable USE ont été appliqués. L'outil à utiliser (<code>revdep-rebuild</code> )  fait partie du paquet <code>gentoolkit</code>. 

{{RootCmd|revdep-rebuild --soname libncurses.so.5
|revdep-rebuild --soname libslang.so.1}}

=== KDE, GNOME et Xfce ===

All of the major desktop environments have full Unicode support, and will require no further setup than what has already been covered in this guide. This is because the underlying graphical toolkits (Qt or GTK+2) are UTF-8 aware. Subsequently, all applications running on top of these toolkits should be UTF-8-aware out of the box. 

The exceptions to this rule come in Xlib and GTK+1. GTK+1 requires a iso-10646-1 FontSpec in the ~/.gtkrc, for example <code>-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1</code> . Also, applications using Xlib or Xaw will need to be given a similar FontSpec, otherwise they will not work. 

{{Note|If you have a version of the gnome1 control center around, use that instead. Pick any iso10646-1 font from there.}}

{{Code|Example ~/.gtkrc (for GTK+1) that defines a Unicode compatible font|<pre>
style "user-font"
{
    fontset="-misc-fixed-*-*-*-*-*-*-*-*-*-*-iso10646-1"
}
widget_class "*" style "user-font"
</pre>
}}

If an application has support for both a Qt and GTK+2 GUI, the GTK+2 GUI will generally give better results with Unicode. 

=== X11 and Fonts ===

TrueType fonts have support for Unicode, and most of the fonts that ship with Xorg have impressive character support, although, obviously, not every single glyph available in Unicode has been created for that font. To build fonts (including the Bitstream Vera set) with support for East Asian letters with X, make sure you have the <code>cjk</code> USE flag set. Many other applications utilise this flag, so it may be worthwhile to add it as a permanent USE flag. 

Also, several font packages in Portage are Unicode aware. 

{{Emerge|terminus-font intlfonts freefonts corefonts}}

=== Window Managers and Terminal Emulators ===

Window managers not built on GTK or Qt generally have very good Unicode support, as they often use the Xft library for handling fonts. If your window manager does not use Xft for fonts, you can still use the FontSpec mentioned in the previous section as a Unicode font. 

Terminal emulators that use Xft and support Unicode are harder to come by. Aside from Konsole and gnome-terminal, the best options in Portage are <code>x11-terms/rxvt-unicode</code> , <code>x11-terms/xfce4-terminal</code> , <code>gnustep-apps/terminal</code> , <code>x11-terms/mlterm</code> , or plain <code>x11-terms/xterm</code> when built with the <code>unicode</code> USE flag and invoked as <code>uxterm</code> . <code>app-misc/screen</code> supports UTF-8 too, when invoked as <code>screen -U</code> or the following is put into the {{Path|~/.screenrc}} : 

{{Code|~/.screenrc for UTF-8|<pre>
defutf8 on
</pre>
}}

=== Vim, Emacs, Xemacs and Nano ===

Vim provides full UTF-8 support, and also has builtin detection of UTF-8 files. For further information in Vim, use <code>:help mbyte.txt</code> . 

Emacs version 23 and Xemacs version 21.5 have full UTF-8 support. Emacs 24 will also support editing bidirectional text. 

Nano has provided full UTF-8 support since version 1.3.6. 

=== Shells ===

Currently, <code>bash</code> provides full Unicode support through the GNU readline library. Z Shell ( <code>zsh</code> ) offers Unicode support with the <code>unicode</code> USE flag. 

The C shell, <code>tcsh</code> and <code>ksh</code> do not provide UTF-8 support at all. 

=== Irssi ===

Irssi has complete UTF-8 support, although it does require a user to set an option. 

{{Cmd|set term_charset UTF-8|prompt=[irssi] }}

For channels where non-ASCII characters are often exchanged in non-UTF-8 charsets, the <code>/recode</code> command may be used to convert the characters. Type <code>/help recode</code> for more information. 

=== Mutt ===

The Mutt mail user agent has very good Unicode support. To use UTF-8 with Mutt, you don't need to put anything in your configuration files. Mutt will work under unicode enviroment without modification if all your configuration files (signature included) are UTF-8 encoded. 

{{Note|You may still see '?' in mail you read with Mutt. This is a result of people using a mail client which does not indicate the used charset. You can't do much about this than to ask them to configure their client correctly.}}

Further information is available from the [http://wiki.mutt.org/index.cgi?MuttFaq/Charset Mutt Wiki] . 

=== Man ===

Man pages are an integral part of any Linux machine. To ensure that any unicode in your man pages render correctly, edit {{Path|/etc/man.conf}} and replace a line as shown below. 

{{Code|man.conf changes for Unicode support|<pre>
## (This is the old line)
NROFF           /usr/bin/nroff -Tascii -c -mandoc
## (Replace the one above with this)
NROFF           /usr/bin/nroff -mandoc -c
</pre>
}}

=== elinks and links ===

These are commonly used text-based browsers, and we shall see how we can enable UTF-8 support on them. On <code>elinks</code> and <code>links</code> , there are two ways to go about this, one using the Setup option from within the browser or editing the config file. To set the option through the browser, open a site with <code>elinks</code> or <code>links</code> and then <code>Alt+S</code> to enter the Setup Menu then select Terminal options, or press <code>T</code> . Scroll down and select the last option <code>UTF-8 I/O</code> by pressing Enter. Then Save and exit the menu. On <code>links</code> you may have to do a repeat <code>Alt+S</code> and then press <code>S</code> to save. The config file option, is shown below. 

{{Code|Enabling UTF-8 for elinks/links|<pre>
## (For elinks, edit /etc/elinks/elinks.conf or ~/.elinks/elinks.conf and
add the following line)
set terminal.linux.utf_8_io = 1

## (For links, edit ~/.links/links.cfg and add the following
line)
terminal "xterm" 0 1 0 us-ascii utf-8
</pre>
}}

=== Samba ===

Samba is a software suite which implements the SMB (Server Message Block) protocol for UNIX systems such as Macs, Linux and FreeBSD. The protocol is also sometimes referred to as the Common Internet File System (CIFS). Samba also includes the NetBIOS system - used for file sharing over windows networks. 

add the following under the [global] section:
{{RootCmd|nano -w /etc/samba/smb.conf|output=<pre>
dos charset = 1255
unix charset = UTF-8
display charset = UTF-8
</pre>
}}

=== Testing it all out ===

There are numerous UTF-8 test websites around. <code>net-www/w3m</code> , <code>net-www/links</code> , <code>net-www/elinks</code> , <code>net-www/lynx</code> and all Mozilla based browsers (including Firefox) support UTF-8. Konqueror and Opera have full UTF-8 support too. 

When using one of the text-only web browsers, make absolutely sure you are using a Unicode-aware terminal. 

If you see certain characters displayed as boxes with letters or numbers inside, this means that your font does not have a character for the symbol or glyph that the UTF-8 wants. Instead, it displays a box with the hex code of the UTF-8 symbol. 

*  [http://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html A W3C UTF-8 Test Page] 
*  [http://titus.uni-frankfurt.de/indexe.htm?/unicode/unitest.htm A UTF-8 test page provided by the University of Frankfurt] 

=== Input Methods ===

''Dead keys'' may be used to input characters in X that are not included on your keyboard. These work by pressing your right Alt key (or in some countries, AltGr) and an optional key from the non-alphabetical section of the keyboard to the left of the return key at once, releasing them, and then pressing a letter. The dead key should modify it. Input can be further modified by using the Shift key at the same time as pressing the AltGr and modifier. 

To enable dead keys in X, you need a layout that supports it. Most European layouts already have dead keys with the default variant. However, this is not true of North American layouts. Although there is a degree of inconsistency between layouts, the easiest solution seems to be to use a layout in the form "en_US" rather than "us", for example. The layout is set in {{Path|/etc/X11/xorg.conf}} like so: 

{{Code|/etc/X11/xorg.conf snippet|<pre>
Section "InputDevice"
    Identifier "Keyboard0"
    Driver     "kbd"
    Option     "XkbLayout" "en_US" ## # Rather than just "us"
    ## (Other Xkb options here)
EndSection
</pre>
}}

{{Note|The preceding change only needs to be applied if you are using a North American layout, or another layout where dead keys do not seem to be working. European users should have working dead keys as is.}}

This change will come into effect when your X server is restarted. To apply the change now, use the <code>setxkbmap</code> tool, for example, <code>setxkbmap en_US</code> . 

It is probably easiest to describe dead keys with examples. Although the results are locale dependent, the concepts should remain the same regardless of locale. The examples contain UTF-8, so to view them you need to either tell your browser to view the page as UTF-8, or have a UTF-8 locale already configured. 

When I press AltGr and [ at once, release them, and then press a, 'ä' is produced. When I press AltGr and [ at once, and then press e, 'ë' is produced. When I press AltGr and ; at once, 'á' is produced, and when I press AltGr and ; at once, release them, and then press e, 'é' is produced. 

By pressing AltGr, Shift and [ at once, releasing them, and then pressing a, a Scandinavian 'å' is produced. Similarly, when I press AltGr, Shift and [ at once, release ''only'' the [, and then press it again, '°' is produced. Although it looks like one, this (U+02DA) is not the same as a degree symbol (U+00B0).

AltGr can be used with alphabetical keys alone. For example, AltGr and m, a Greek lower-case letter mu is produced. AltGr and s produce a scharfes s or esszet, etc. As many European users would expect (because it is marked on their keyboard), AltGr and 4 (or E depending on the keyboard layout) produces a Euro sign, '€'. 

=== Resources ===

*  [http://en.wikipedia.org/wiki/Unicode The Wikipedia entry for Unicode] 
*  [http://en.wikipedia.org/wiki/UTF-8 The Wikipedia entry for UTF-8] 
*  [http://www.unicode.org Unicode.org] 
*  [http://www.utf-8.com UTF-8.com] 
*  [http://www.ietf.org/rfc/rfc3629.txt RFC 3629] 
*  [http://www.ietf.org/rfc/rfc2277.txt RFC 2277] 
*  [http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF Characters vs. Bytes] 

== Reported Issues or Problems ==

=== System Configuration Files (in /etc) ===

Most system configuration files, such as {{Path|/etc/fstab}} , do not support UTF-8. It is recommended to stick with the ASCII character set for these files. 

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* Thomas Martin
* Alexander Simonov
* Shyam Mani
* nightmorph
