<languages />

{{Metadata|abstract=Questa guida costituisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.}}

Questa guida costituisce un'introduzione all'ottimizzazione del codice compilato utilizzando valori sicuri per le variabili CFLAGS e CXXFLAGS. Inoltre viene descritta la teoria a fondamento dell'ottimizzazione in generale.

== Introduzione ==

=== Cosa sono CFLAGS e CXXFLAGS? ===

CFLAGS and CXXFLAGS are environment variables that are used to tell the GNU Compiler Collection (<kbd>gcc</kbd>) what kinds of switches to use when compiling source code. CFLAGS are for code written in C, while CXXFLAGS are for code written in C++. 

Possono essere usate per ridurre la quantità di messaggi per il debug, per incrementare i livelli dei messaggi di avvertimento e ovviamente per ottimizzare il codice prodotto. Il [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuale GCC] contiene una lista completa delle opzioni disponibili, e per ciascuna di esse viene fornita una spiegazione del motivo per cui vengono usate. 

=== Come vengono usate? ===

CFLAGS and CXXFLAGS can be used in two ways. First, they can be used per-program with Makefiles generated by <kbd>automake</kbd>. 

Tuttavia ciò non dovrebbe essere fatto quando si installano pacchetti di Portage. È preferibile invece impostare le CFLAGS e le CXXFLAGS nel file {{Path|/etc/portage/make.conf}}. In questo modo tutti i pacchetti vengono compilati usando le stesse impostazioni. 

{{CodeBox|title=CFLAGS in /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|While it is possible to have multiple lines in USE flags, doing the same in CFLAGS can and will result in problems with programs such as <kbd>cmake</kbd>. Make sure your CFLAGS declaration is on a single line, with as little whitespace as possible to avoid those issues. See {{Bug|500034}} as an example.}}

Come è possibile vedere le CXXFLAGS sono state impostate con le stesse opzioni presenti nelle CFLAGS. Si tratta della configurazione più sicura, e in genere non dovrebbe mai sorgere la necessità di specificare opzioni diverse per le CXXFLAGS.

=== Convinzioni errate ===

Anche se le CFLAGS e le CXXFLAGS possono essere un modo molto valido per ottenere codice binario più piccolo o più veloce esse, se utilizzate in modo errato, possono anche compromettere la funzionalità del codice stesso, aumentare a dismisura le sue dimensioni, ridurre drasticamente le prestazioni o anche provocare errori di compilazione! 

Le CFLAGS non sono una panacea ad ogni male: non rendono sempre il sistema dell'utente più veloce e non riducono sempre le dimensioni del codice binario. Aggiungere sempre più flag nell'intento di ottimizzare sempre più il sistema conduce sicuramente al fallimento. C'è un punto oltre al quale si ottengono miglioramenti ogni volta più scarsi. 

A dispetto di certe informazioni che è possibile trovare su Internet, CFLAGS e CXXFLAGS aggressive fanno solitamente più male che bene alla maggior parte dei programmi. Occorre tenere presente che molte opzioni sono state progettate per essere usate in situazioni particolari e per ragioni specifiche. Il fatto che una certa opzione sia positiva per una determinata porzione di codice non significa che tale opzione sia per questo adatta ad essere utilizzata globalmente per compilare tutti i programmi del sistema! 

=== Pronto? ===

Adesso che il lettore è stato informato dei possibili rischi è possibile esaminare alcune ottimizzazioni sicure, utilizzando le quali si ha l'approvazione degli sviluppatori quando si segnala un problema su [http://bugs.gentoo.org Bugzilla]. Gli sviluppatori di solito richiedono all'utente di ricompilare il pacchetto problematico con un insieme ridotto di CFLAGS per vedere se il problema persiste. Si ricordi che opzioni aggressive possono rovinare il codice. 

== Ottimizzazione ==

=== Le basi ===

The goal behind using CFLAGS and CXXFLAGS is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so we'll stick with combinations known to work well. Ideally, they are the best available for any CPU architecture. We'll mention the aggressive flags later so you know what to look out for. We won't discuss every option listed on the <kbd>gcc</kbd> manual (there are hundreds), but we'll cover the basic, most common flags. 

{{Note|Whenever you're not sure what a flag actually does, refer to the relevant chapter of the [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual] . If you're still stumped, try Google, or check out the <kbd>gcc</kbd> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

La prima e più importante opzione è <code>-march</code>. Questa comunica al compilatore di produrre codice per una certa [https://it.wikipedia.org/wiki/Microarchitettura architettura] di processori. CPU diverse possiedono diverse funzionalità, supportano diversi insiemi di istruzioni e hanno diverse modalità di eseguire il codice. L'opzione <code>-march</code> indica al compilatore di produrre codice specifico per una data CPU, considerando tutte le sue funzionalità, gli insiemi di istruzioni e le modalità di eseguire il codice. 

Anche se la variabile CHOST nel file {{Path|/etc/portage/make.conf}} specifica già l'architettura generica da utilizzare, <code>-march</code> dovrebbe comunque essere utilizzata anch'essa in modo da ottimizzare il codice per uno specifico processore. In particolare sono le CPU x86 e x86-64 che dovrebbero utilizzare l'opzione <code>-march</code>. 

Quale CPU si possiede? Per scoprirlo, si esegua il seguente comando: 

{{Cmd|cat /proc/cpuinfo}}

To get more details, including <code>march</code> and <code>mtune</code> values, use:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Questo è un esempio per un vecchio Pentium III: 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

Questo è invece un esempio per una CPU AMD a 64-bit: 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

Se non si è sicuri di sapere quale CPU si possiede ci si può semplicemente limitare ad utilizzare l'opzione <code>-march=native</code>. Con questa opzione GCC determina automaticamente di quale processore si dispone e imposta di conseguenza le opzioni più appropriate. '''Questa opzione, tuttavia, non dovrebbe essere utilizzata qualora si intenda compilare pacchetti per una CPU differente!''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <code>CFLAGS</code> or <code>CXXFLAGS</code> variables of {{Path|make.conf}} when compiling with <tt>[[Distcc#-march.3Dnative|distcc]]</tt>.}}

Se il lettore sta compilando pacchetti su un certo computer ma intende eseguirli su un computer diverso (ad esempio nel caso in cui si dispone di un computer veloce che compila pacchetti da utilizzare su un'altro computer più lento) ''non'' bisogna utilizzare l'opzione <code>-march=native</code>. ''Native'' significa che il codice prodotto da una certa CPU potrà essere eseguito ''solo'' su quel tipo di CPU. Le applicazioni compilate con <code>-march=native</code> su una CPU AMD Athlon 64 non potranno essere eseguite su una vecchia CPU VIA C3. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, <kbd>gcc</kbd>'s behavior isn't very consistent with how each flag behaves from one architecture to the next. 

Per CPU x86 o x86-64 <code>-march</code> genera codice specifico per una data CPU usando gli insiemi di istruzioni disponibili e la corretta ABI; non viene garantita la compatibilità con CPU diverse o con CPU più vecchie. Se non si necessita di eseguire codice su un sistema diverso da quello sul quale è presente Gentoo si può continuare ad utilizzare <code>-march</code>. Il lettore dovrebbe considerare l'utilizzo di <code>-mtune</code> solamente se abbia la necessità di generare codice per CPU quali i386 o i486. <code>-mtune</code> produce codice più generico che nel caso di <code>-march</code>; anche se ottimizza il codice per una certa CPU non prende in considerazione gli insiemi di istruzioni o l'ABI disponibile. Non utilizzare <code>-mcpu</code> su sistemi x86 o x86-64 in quanto è obsoleta su queste architetture. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64)... but with a different flag name. Again, <kbd>gcc</kbd>'s behavior and flag naming just isn't consistent across architectures, so be sure to check the <kbd>gcc</kbd> [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one you should use for your system. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for your arch. Also, read the <kbd>gcc</kbd> manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

La prossima variabile da considerare è <code>-O</code>. Essa permette di controllare il livello complessivo di ottimizzazione. Con <code>-O</code> la compilazione del codice richiede un po' più di tempo e potrebbe richiedere molta più memoria, specialmente se si innalza il livello di ottimizzazione. 

Esistono sette possibili impostazioni per <code>-O</code>: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code> e <code>-Ofast</code>. Occorre scegliere solo una tra le precendenti impostazioni e applicarla nel file {{Path|/etc/portage/make.conf}}. 

Con la sola eccezione di <code>-O0</code>, ciascuna delle impostazioni <code>-O</code> attiva alcune opzioni aggiuntive. Assicurarsi quindi di leggere il capitolo del manuale GCC sulle [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options opzioni per l'ottimizzazione] per capire quali opzioni vengono attivate per ciascuno dei livelli <code>-O</code> e qual'è la loro funzione. 

Esaminiamo assieme ciascuno dei livelli di ottimizzazione: 

* <code>-O0</code>: Si noti che si tratta della lettera "O" seguita da uno zero. Questo livello disattiva del tutto l'ottimizzazione del codice ed è la scelta predefinita qualora nessuna opzione <code>-O</code> venga specificata tra le CFLAGS o le CXXFLAGS. <code>-O0</code> riduce i tempi per la compilazione e può migliorare le informazioni per il debug, ma alcune applicazioni potrebbero non funzionare correttamente se l'ottimizzazione è disattivata completamente. Questa opzione non è pertanto consigliata, a meno che la si scelga per effettuare il debug delle applicazioni.

* <code>-O1</code>: Questo è il livello di ottimizzazione base. Con <code>-O1</code> il compilatore prova a produrre codice più veloce e più snello senza richiedere troppo tempo per la compilazione. Si tratta di una opzione piuttosto basilare, ma dovrebbe funzionare in qualsiasi circostanza.

* <code>-O2</code>: È il passo successivo rispetto a <code>-O1</code>. Si tratta del livello di ottimizzazione "raccomandato" a meno di esigenze particolari. <code>-O2</code> attiva alcune ulteriori opzioni rispetto a quelle utilizzate da <code>-O1</code>. Con <code>-O2</code> il compilatore prova ad incrementare le prestazioni del codice prodotto senza richiedere troppo tempo per la compilazione.

* <code>-O3</code>: Questo è il più alto livello di ottimizzazione possibile. Vengono attivate ottimizzazioni che sono costose dal punto di vista del tempo di compilazione e dell'utilizzo di memoria. Compilare con <code>-O3</code> non è un modo sicuro di migliorare le prestazioni del codice; in molti casi si ottiene il rallentamento del sistema a causa del codice binario più grande e dell'utilizzo maggiore di memoria. <code>-O3</code> è anche nota per causare la corruzione di alcuni pacchetti. Per queste ragioni l'utilizzo di <code>-O3</code> non è consigliato.

* <code>-Os</code>: Questa opzione ottimizza il codice dal punto di vista delle sue dimensioni. Essa attiva tutte le opzioni di <code>-O2</code> che non causano l'incrementano delle dimensioni del codice prodotto. <code>-Os</code> può essere utile per macchine che hanno una capacità di archiviazione su disco estremamente limitata o CPU con cache dalla dimensione ridotta.

* <code>-Og</code>: Questa opzione è stata introdotta con GCC 4.8. Essa soddisfa il bisogno di ridurre i tempi della compilazione e quello di migliorare la capacità di effettuare il debug mantenendo però un ragionevole livello prestazionale in fase di esecuzione. Complessivamente con <code>-Og</code> l'attività di sviluppo dovrebbe risultare migliore rispetto a <code>-O0</code>. Si noti che <code>-Og</code> non implica <code>-g</code>; <code>-Og</code> si limita semplicemente a disattivare le ottimizzazioni che hanno ripercussioni negative sull'attività di debug.

* <code>-Ofast</code>: Si tratta di un'opzione introdotta con GCC 4.7. Essa consiste della somma di <code>-O3</code> con <code>-ffast-math</code>, <code>-fno-protect-parens</code> e <code>-fstack-arrays</code>. <code>-Ofast</code> viola la conformità stretta agli standard e pertanto non è consigliata.

Come menzionato precedentemente <code>-O2</code> è il livello di ottimizzazione consigliato. Se un pacchetto crea problemi in fase di compilazione e non si sta utilizzando <code>-O2</code> si riprovi attivando questa opzione. In alternativa provare ad impostare le variabili CFLAGS e CXXFLAGS ad un livello di ottimizzazione più basso, come ad esempio <code>-O1</code> o addirittura <code>-O0 -g2 -ggdb</code>.

=== -pipe ===

Un'opzione piuttosto comune è <code>-pipe</code>. Essa non ha effetti sul codice generato ma rende più rapido il processo di compilazione. <code>-pipe</code> comunica al compilatore di utilizzare pipe al posto di file temporanei durante le varie fasi della compilazione, con la conseguenza di richiedere maggiore memoria. Tale opzione potrebbe causare problemi su sistemi con una disponibilità bassa di memoria perché GCC potrebbe venire terminato. In questo caso si consiglia di non utilizzare questa opzione. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <kbd>gcc</kbd> manual does not specify all architectures it is turned on by using <code>-O</code>, you will need to explicitly activate it on x86, with <kbd>gcc</kbd> up to version 4.6 or when using <code>-Os</code>. However, using this flag will make debugging hard to impossible. 

In particolare <code>-fomit-frame-pointer</code> rende molto più difficile l'attività di diagnostica delle applicazioni scritte in Java, ma questo non è l'unico linguaggio interessato. Inoltre attivando <code>-fomit-frame-pointer</code> l'attività di debug attraverso le backtrace è impossibile da svolgersi in quanto esse sono del tutto inutilizzabili. Ad ogni modo questa opzione può essere utilizzata se non si ha la necessità di svolgere il debug del software e non si è scelto di attivare opzioni per il debug quale ad esempio <code>-ggdb</code>. 

{{Important/it|''Non'' combinare <code>-fomit-frame-pointer</code> con l'opzione <code>-momit-leaf-frame-pointer</code>. L'uso di quest'ultima è scoraggiato in quanto la prima svolge già da sola la propria funzione in modo corretto. Inoltre <code>-momit-leaf-frame-pointer</code> è nota per avere conseguenze negative sulle prestazioni del codice.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Queste opzioni attivano sulle architetture x86 e x86-64 gli insiemi di istruzioni [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE], [http://en.wikipedia.org/wiki/SSE2 SSE2], [http://en.wikipedia.org/wiki/SSSE3 SSE3], [http://en.wikipedia.org/wiki/MMX MMX] e [http://en.wikipedia.org/wiki/3dnow 3DNow!]. Tali opzioni sono utili principalmente in ambito multimediale o ludico e per svolgere compiti che richiedono un utilizzo intensivo della virgola mobile. Questi insiemi di istruzioni si trovano soprattutto nelle CPU più moderne. 

{{Important/it|Per assicurarsi che la propria CPU supporti queste opzioni è possibile eseguire il comando <code>cat /proc/cpuinfo</code>. Nell'output vi è la lista degli insiemi di istruzioni supportati. Si noti che '''pni''' sta per SSE3.}}

Normalmente non è necessario aggiungere alcuna di queste opzioni al file {{Path|/etc/portage/make.conf}} a patto di utilizzare l'opzione <code>-march</code> corretta (ad esempio <code>-march=nocona</code> implica <code>-msse3</code>). Alcune eccezioni rilevanti a questa regola sono le CPU VIA e AMD64 più recenti, in quanto esse supportano insiemi di istruzioni, quali SSE3, che <code>-march</code> non include. Se si possiedono tali CPU si consiglia di controllare l'output di <code>cat /proc/cpuinfo</code> e di attivare le opzioni aggiuntive del caso. 

{{Note/it|Il lettore dovrebbe controllare la [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_64-Options.html#i386-and-x86_64-Options lista] delle opzioni specifiche per x86 e x86-64 in modo da capire quali di questi insiemi di istruzioni vengono attivati selezionando l'opzione corretta per la propria CPU. Se un insieme di istruzioni compare nella lista non è necessario specificarlo a mano perché viene attivato automaticamente utilizzando l'impostazione corretta di <code>-march</code>.}}

== Domande frequenti ==

=== Ma ottengo migliori prestazioni con -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <kbd>gcc</kbd> [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

La verità è che si tratta di opzioni aggressive e pericolose. Si invita il lettore a controllare il [[https://forums.gentoo.org/ forum]] e il [[https://bugs.gentoo.org/ bugzilla]] di Gentoo per vedere quali sono le conseguenze di queste opzioni. Niente di buono! 

Non bisogna aggiungere queste opzioni alle CFLAGS o alle CXXFLAGS. Esse possono indurre il lettore a credere di avere un sistema ad alte prestazioni e all'avanguardia, ma la realtà è che esse danneggiano il codice e costringono gli sviluppatori a chiudere i bug come INVALID o WONTFIX. 

Non c'è bisogno di utilizzare tali opzioni. '''Non usarle'''. Limitarsi alle opzioni di base: <code>-march</code>, <code>-O</code> e <code>-pipe</code>.

=== Livelli per -O maggiori di 3 ===

Alcuni utenti si vantano di ottenere prestazioni maggiori usando <code>-O4</code>, <code>-O9</code> e simili. In realtà i livelli per <code>-O</code> maggiori di 3 non hanno alcun effetto. Il compilatore accetta CFLAGS come <code>-O4</code>, ma in questi casi esso si limita ad applicare le ottimizzazioni del livello <code>-O3</code> e niente di più. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

Il lettore può osservare che i valori maggiori di 3 sono trattati allo stesso modo che per <code>-O3</code>.

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Opzioni ridondanti ===

Spesso le CFLAGS e le CXXFLAGS che sono attivate ai vari livelli di <code>-O</code> vengono specificate in modo ridondante nel file {{Path|/etc/portage/make.conf}}. Alcune volte lo si fa per ignoranza, ma in altri casi lo scopo è quello di aggirare la sostituzione o il filtraggio delle opzioni. 

Il filtraggio e la sostituzione delle opzioni vengono svolti da molti ebuild. Solitamente lo si fa perché alcuni pacchetti non possono essere compilati a determinati livelli di <code>-O</code>, oppure perché il codice sorgente è troppo sensibile per permettere l'uso di opzioni aggiuntive. Tali ebuild possono filtrare alcune CFLAGS/CXXFLAGS o possono sostituire <code>-O</code> con un livello differente. 

Il [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] spiega nel dettaglio in che modo funziona il filtraggio e la sostituzione delle opzioni e dove essi hanno luogo. 

È possibile aggirare il filtraggio delle opzioni attivate ad un certo livello di <code>-O</code>, come ad esempio <code>-O3</code>, nel seguente modo: 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Questa, tuttavia, '''non è affatto una buona idea'''. Le CFLAGS sono filtrate per una ragione ben precisa! Tali opzioni vengono filtrate perché altrimenti non si è sicuri di riuscire a compilare un pacchetto correttamente. Ovviamente ''non'' è sicuro compilare l'intero sistema con <code>-O3</code> se alcune delle opzioni attivate da tale livello causano problemi con certi pacchetti. Il lettore non dovrebbe cercare di "raggirare" gli sviluppatori che mantengono questi pacchetti. ''Occorre fidarsi degli sviluppatori''. Il filtraggio e la sostituzione delle opzioni viene fatto ad esclusivo vantaggio dell'utente finale. Se un ebuild specifica opzioni alternative non bisogna pertanto provare ad aggirarle. 

Se si sceglie di compilare un pacchetto con opzioni inaccettabili è molto probabile che si avranno ulteriori problemi successivamente. Quando l'utente segnala un problema sul Bugzilla le opzioni che si usano in {{Path|/etc/portage/make.conf}} sono chiaramente visibili a tutti e gli sviluppatori chiederanno senz'altro di ricompilare il pacchetto senza le opzioni problematiche. Si può evitare il fastidio di dover ricompilare tali pacchetti se si evita in primo luogo di utilizzare opzioni ridondanti in questa maniera. Non si deve assumere di saperne di più rispetto agli sviluppatori.

=== LDFLAGS ===

Gli sviluppatori Gentoo hanno già scelto un insieme minimo e sicuro di LDFLAGS nei profili di base, pertanto non è necessario che l'utente vada a modificarle. 

=== Opzioni specifiche per un singolo pacchetto ===

{{Warning/it|Utilizzare opzioni specifiche per un singolo pacchetto rende più complicato il debug e l'assistenza. Se si sceglie di continuare per questa strada e si vuole segnalare un problema agli sviluppatori si faccia esplicito riferimento al fatto che si sta utilizzando questa funzionalità, e si indichino inoltre le modifiche che sono state apportate.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Risorse ==

Le seguenti risorse sono utili per approfondire ulteriormente il tema dell'ottimizzazione: 

* La [http://gcc.gnu.org/onlinedocs/ documentazione per GCC] 

* Chapter 5 of the [[Handbook:Main_Page|Gentoo Installation Handbooks]]

* <kbd>man make.conf</kbd>

* [https://it.wikipedia.org/ Wikipedia]

* I [https://forums.gentoo.org/ forum Gentoo]

{{Migrated|originalauthors=nightmorph}}
