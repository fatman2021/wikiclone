<languages />

Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

Флаги CFLAGS и CXXFLAGS - это переменные среды, которые используются для сообщения компиляторам GNU Compiler Collection, <code>GCC</code>, какие виды ключей использовать при компиляции исходного кода. CFLAGS используются для кода написанного на C, в то время как флаги CXXLFAGS - для кода написанного на C++. 

Они могут быть использованы для уменьшения количества отладочных сообщений программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC GCC manual] поддерживает полный список доступных параметров и их предназначений. 

=== Как их использовать? ===

Флаги CFLAGS и CXXFLAGS могут использоваться двумя путями. Во-первых, они могут использоваться на уровне единственной программы с помощью make-файлов, генерируемых утилитой automake. 

Однако, Вы не должны делать этого при установке пакетов, находящихся в дереве портежей. Вместо этого, установите Ваши CFLAGS и CXXFLAGS флаги в {{Path|/etc/portage/make.conf}} . Таким образом все пакеты будут скомпилированы с использованием параметров, которые Вы укажете. 

{{Code/ru|Флаги CFLAGS в /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Как видите, CXXFLAGS настроены на использование всех параметров, присутствующих в CFLAGS. Это то, что Вам потребуется почти безусловно. Вам вовсе не надобно указывать дополнительные параметры в CXXFLAGS. 

=== Заблуждения ===

В то время как CFLAGS и CXXFLAGS могут быть очень эффективными средствами генерации менее объемных или более быстрых двоичных файлов из исходного кода, они также могут нарушить функционирование Вашего кода, увеличить его объем, замедлить время исполнения, или вызвать серьезные ошибки компиляции! 

CFLAGS - это не панацея; они не смогут автоматически заставить Вашу систему работать быстрее или двоичные файлы занимать меньше места на диске. Добавление все большего и большего количества флагов в попытке оптимизировать (или "разогнать") систему - верный рецепт для неудачи. Существует точка, в которой Вы достигнете худших результатов. 

Вопреки хвастовству, которое Вы найдете в Интернете, агрессивные флаги компиляции CFLAGS и CXXFLAGS, скорее всего, принесут больше вреда, чем пользы для Ваших программ. Держите в уме, что причина, по которой флаги существуют с самого начала - это потому что они созданы для использования в определенном месте с определенной целью. Просто потому что один отдельный CFLAG хорош для одного участка кода, вовсе не означает что он подходит для компиляции всего, что Вы можете установить на Ваш компьютер! 

=== Готовы? ===

Теперь, когда Вы знаете о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций для Вашего компьютера. Они окажут Вам большую пользу и расположат к Вам разработчиков в следующий раз, когда Вы будете сообщать о проблеме на [http://bugs.gentoo.org Bugzilla] . (Разработчики обычно просят вас перекомпилировать пакет с минимальным количеством переменных CFLAGS для того, чтобы определить, продолжает ли проблема существовать. Запомните, агрессивные флаги могут разрушить код.) 

== Оптимизация ==

=== Основы ===

The goal behind using CFLAGS and CXXFLAGS is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so we'll stick with combinations known to work well. Ideally, they are the best available for any CPU architecture. We'll mention the aggressive flags later so you know what to look out for. We won't discuss every option listed on the <code>GCC</code> manual (there are hundreds), but we'll cover the basic, most common flags. 

{{Note|Whenever you're not sure what a flag actually does, refer to the relevant chapter of the [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual] . If you're still stumped, try Google, or check out the <code>GCC</code> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

Самой первым, и наиболее важным параметром, является <code>-march</code> . Он сообщает компилятору какой код он должен генерировать для [http://en.wikipedia.org/wiki/Microarchitecture архитектуры] Вашего процессора; он сообщает компилятору, что тот должен генерировать код для определенного типа CPU. Разные типы CPU имеют разные возможности, поддерживают различные наборы команд, и обладают разными способами исполнения кода. Флаг <code>-march</code> проинструктирует компилятор генерировать код специально для Вашего типа CPU, со всеми доступными возможностями, особенностями, наборами команд, интересными функциями, и так далее. 

Хотя переменная CHOST в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для Вашего конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU Вы имеете? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{Code/ru|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

А это другой пример для 64-разрядного AMD CPU: 

{{Code/ru|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Если Вы все еще не уверены, каким видом CPU Вы обладаете, вы можете просто использовать параметр <code>-march=native</code> . Когда используется этот флаг, GCC попытается распознать Ваш процессор и автоматически установит для него подходящие флаги. '''Однако, Вы не должны его использовать, если Вы собираетесь компилировать пакеты для другого CPU!''' 

Итак, если вы компилируете пакеты на одном компьютере, но собираетесь запускать их на другом (например, используя сборку на быстром компьютере для более медленного, старого компьютера), тогда ''не используйте'' <code>-march=native</code> . ''Native'' означает, что генерируемый код будет запускаться ''только'' на том типе CPU, на котором он был собран. Приложения скомпилированные с <code>-march=native</code> на процессоре AMD Athlon 64 CPU не смогут запуститься на более старом VIA C3 CPU. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, <code>GCC</code>'s behavior isn't very consistent with how each flag behaves from one architecture to the next. 

На процессорах x86 и x86-64, параметр <code>-march</code> будет генерировать код, предназначенный специально для этих типов процессоров, используя все доступные наборы команд и корректный двоичный интерфейс приложений; он не будет обладать обратной совместимостью с более старыми/другими типами процессоров. Если Вам не требуется исполнять код на чем либо другом, кроме системы, на которой работает Gentoo, продолжайте использовать <code>-march</code> . Вы должны рассмотреть использование <code>-mtune</code> только тогда, когда Вам необходимо сгенерировать код для более старых процессоров, таких как i386 и i486. Параметр <code>-mtune</code> производит более общий код, чем <code>-march</code>; хотя он и настроит код под определенный процессор, он не будет рассматривать доступные наборы команд и двоичный интерфейс приложений. Не используйте <code>-mcpu</code> на системах с x86 или x86-64, так как это не рекомендуется для этих архитектур. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64)... but with a different flag name. Again, <code>GCC</code>'s behavior and flag naming just isn't consistent across architectures, so be sure to check the <code>GCC</code> [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one you should use for your system. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbook] for your arch. Also, read the <code>GCC</code> manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Следующая по списку - переменная <code>-O</code> . Она управляет всем уровнем оптимизации. Это приводит к тому, что компиляция кода занимает больше времени, и сможет занять гораздо больше памяти, особенно когда  Вы увеличиваете уровень оптимизации. 

Существует пять видов настроек для переменной <code>-O</code>: <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , и <code>-Os</code> . Вы должны использовать только одну из них в {{Path|/etc/portage/make.conf}} . 

With the exception of <code>-O0</code> , the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options optimization options] to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 

Давайте исследуем каждый уровень оптимизации: 

*  <code>-O0</code> : This level (that's the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in CFLAGS or CXXFLAGS.  This reduces compilation time and can improve debugging info, but some applications will not work properly without optimization enabled.  This option is not recommended except for debugging purposes.

* <code>-O1</code> : Это наиболее простой уровень оптимизации. Компилятор попытается сгенерировать быстрый, занимающий меньше объема код, без затрачивания наибольшего времени компиляции. Он достаточно простой, но должен всегда выполнять свою работу.

* <code>-O2</code> : Шаг вперед из <code>-O1</code> . Это ''рекомендуемый'' уровень оптимизации, до тех пор пока Вам не понадобится что-то особенное. <code>-O2</code> активирует несколько дополнительных флагов вдобавок к флагам, активированным на <code>-O1</code> . С параметром <code>-O2</code> , компилятор попытается увеличить производительность кода без нарушения размера, и без затрачивания большого количества времени компиляции.

*  <code>-O3</code> : This is the highest level of optimization possible.  It enables optimizations that are expensive in terms of compile time and memory usage.  Compiling with <code>-O3</code> is not a guaranteed way to improve performance, and in fact in many cases can slow down a system due to larger binaries and increased memory usage.  <code>-O3</code> is also known to break several packages.  Therefore, using <code>-O3</code> is not recommended.

*  <code>-Os</code> : This option will optimize your code for size. It activates all <code>-O2</code> options that don't increase the size of the generated code. It can be useful for machines that have extremely limited disk storage space and/or have CPUs with small cache sizes.

*  <code>-Og</code> : In GCC 4.8, a new general optimization level, -Og, has been introduced. It addresses the need for fast compilation and a superior debugging experience while providing a reasonable level of runtime performance. Overall experience for development should be better than the default optimization level -O0.  Note that -Og does not imply -g, it simply disables optimizations that may interfere with debugging.

As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and you aren't using <code>-O2</code>, try rebuilding with that option.  As a fallback option, try setting your CFLAGS and CXXFLAGS to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, GCC might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <code>GCC</code> manual does not specify all architectures it is turned on by using <code>-O</code>, you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

В частности, это делает устранение неполадок в Java-приложениях намного сложнее, хотя код, написанный на Java - не единственный, который затронут использованием этого флага. Поэтому, в то время как использование этого флага может помочь, оно также затрудняет отладку; трассировка стека, в частности, будет бесполезна. Однако, если Вы не планируете отлаживать большое количество программ и не добавляли какие-либо другие переменные CFLAGS, связанные с отладкой, такие как <code>-ggdb</code> , то Вы можете попытаться использовать <code>-fomit-frame-pointer</code> . 

{{Important/ru|''Не комбинируйте''<code>-fomit-frame-pointer</code> с подобным флагом <code>-momit-leaf-frame-pointer</code> . Использование последнего флага не рекомендуется, так как <code>-fomit-frame-pointer</code> уже выполняет всю работу. Кроме того, показано, что <code>-momit-leaf-frame-pointer</code> негативно влияет на производительность кода. }}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Эти флаги разрешают наборы команд [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , и [http://en.wikipedia.org/wiki/3dnow 3DNow!] для архитектур x86 и x86-64. Они используются в основном в мультимедиа, играх, и других вычислительных задачах с интенсивным использованием плавающей точки, хотя они также включают несколько других математических расширений. Эти наборы команд предоставляются большинством современных процессоров. 

{{Important/ru|Убедитесь, что Вы проверили Ваш процессор на их поддержку, введя команду <code>cat /proc/cpuinfo</code> . Результат будет включать любые дополнительные наборы команд, которые поддерживаются Вашим процессором. Заметьте, что '''pni''' - это просто другое имя для SSE3.}}

Обычно, Вы не нуждаетесь в добавлении каких-либо из этих флагов в {{Path|/etc/portage/make.conf}} пока Вы используете корректный параметр <code>-march</code> (например, <code>-march=nocona</code> подразумевает использование <code>-msse3</code> ). Некоторые заметные исключения - новые процессоры VIA и AMD64, которые поддерживают инструкции, не включаемые параметром <code>-march</code> (такие как SSE3). Для таких процессоров, Вам нужно включить дополнительные флаги, где это доступно, после проверки результата работы команды <code>cat /proc/cpuinfo</code> . 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== FAQ по оптимизации ==

=== Но я получаю лучшую производительность с -funroll-loops -fomg-optimize! ===

Нет, Вам только ''кажется'' что Вы получаете лучшую производительность, потому что кто-то Вас убедил в том, что чем больше флагов, тем лучше. Агрессивные флаги только повредят Вашим приложениям при глобальном использовании. Даже <code>GCC</code>  [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] говорит, что использование параметров <code>-funroll-loops</code> и <code>-funroll-all-loops</code> увеличит объем кода и время его исполнения. Хотя, по каким-то причинам, эти два флага, вместе с флагами <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, и им подобными, продолжают пользоваться популярностью среди гонщиков, которые хотят повысить чувство собственной важности. 

Истина в том, что это чрезвычайно агрессивные флаги. Посмотрите по [http://forums.gentoo.org форумам Gentoo] и [http://bugs.gentoo.org Bugzilla], чтобы увидеть, что эти флаги могут сделать: ничего хорошего! 

Вам не нужно использовать эти флаги глобально, в переменных CFLAGS и CXXFLAGS. Они только ухудшат производительность. Может показаться, что Вы имеете высокопроизводительную систему, работающую по последнему слову техники, но они не делают ничего, кроме раздувания кода и приводят к тому, что Ваши сообщения о багах помечаются как INVALID или WONTFIX. 

Вам не требуются такие опасные флаги, как эти. '''Не используйте их'''. Придерживайтесь основ: <code>-march</code> , <code>-O</code> , и <code>-pipe</code> .

=== Что по поводу уровней оптимизации -O больших чем 3? ===

Некоторые пользователи хвалятся даже большей производительностью, достигнутой использованием <code>-O4</code> , <code>-O9</code> , и так далее, но в действительности, уровни <code>-O</code> большие чем 3 не имеют никакого эффекта. Компилятор может принимать переменные CFLAGS, такие как <code>-O4</code> , но, на самом деле, ничего с ними не делать. Он только выполняет оптимизацию до уровня <code>-O3</code> , и ничего больше: 

Need more proof? Examine the <code>code</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code]: 

{{Code/ru|Исходный код параметра -O|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

Как видите, любое значение, большее тройки, рассматривается как <code>-O3</code> .

=== А что об избыточных флагах? ===

Часто переменные CFLAGS и CXXFLAGS, которые включаются на разных уровнях <code>-O</code>, указаны избыточно в {{Path|/etc/portage/make.conf}} . Иногда, это сделано по неосведомленности, но также и для того, чтобы избежать отфильтровывание флагов или их замещение. 

Фильтрация/замещение флагов используется во многих ebuild-файлах, находящихся в дереве портежей. Обычно, это делается потому что пакеты не компилируются на определенных уровнях <code>-O</code>, или когда исходный код очень чувствителен к дополнительно используемым флагам. Ebuild-файл или отфильтровывает некоторые или все переменные CFLAGS и CXXFLAGS, или может заменить <code>-O</code> другим уровнем. 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Руководство разработчика Gentoo] описывает в общих чертах, где и как работает фильтрация/замещение флагов. 

Возможно обойти фильтрацию уровней <code>-O</code>, избыточно перечисляя флаги для определенного уровня, например <code>-O3</code> , делая такие вещи как: 

{{Code/ru|Указание избыточных CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

Однако, '''это не самая умная вещь, которую можно сделать'''. CFLAGS отфильтровываются не зря! Когда флаги фильтруются, это означает, что собирать пакет с этими флагами небезопасно. Очевидно, что ''небезопасно'' компилировать всю Вашу систему с <code>-O3</code> если некоторые из флагов, включенных на этом уровне, вызовут проблемы с определенными пакетами. Следовательно, Вы не должны пытаться ''обхитрить'' разработчиков, которые поддерживают эти пакеты. ''Доверяйте разработчикам''. Фильтрация флагов и их замена делаются для вашей же пользы! Если ebuild-файл указывает альтернативные флаги, то не пытайтесь это обойти. 

Скорее всего, вы продолжите испытывать проблемы, когда Вы собираете пакет с недопустимыми флагами. При сообщении о проблемах на Bugzilla, флаги, которые Вы используете в {{Path|/etc/portage/make.conf}} будут легко видны, и Вам скажут, чтобы Вы перекомпилировали пакет без этих флагов. Сохраните себя от проблем с перекомпиляцией не используя избыточные флаги с самого начала! Не предполагайте автоматически, что Вы знаете больше, чем разработчики.

=== Что по поводу LDFLAGS? ===

Разработчики Gentoo уже установили простые, безопасные LDFLAGS в базовых профилях, поэтому Вам не нужно их изменять. 

=== Могу ли я использовать флаги для отдельных пакетов? ===

{{Warning/ru|Использование флагов для отдельных пакетов затрудняет отладку и поддержку. Удостоверьтесь, что Вы упоминаете в Ваших баг-репортах об использовании этой возможности и об изменениях, которые Вы внесли.}}

Информация об использовании переменных среды для каждого пакета по отдельности (включая CFLAGS) описана в  [http://www.gentoo.org//doc/ru/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 настольной книге Gentoo, "Переменные окружения для отдельных пакетов"] .

== Источники ==

Следующие источники могут быть полезными в дальнейшем изучении оптимизации: 

* The [http://gcc.gnu.org/onlinedocs/ GCC online documentation] 

* Глава 5 [http://www.gentoo.org//doc/ru/handbook/ настольной книги по установке Gentoo] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* [http://forums.gentoo.org форумы Gentoo]

== Благодарности ==

Мы хотели бы поблагодарить следующих авторов и редакторов за их вклад в это руководство:

* nightmorph
