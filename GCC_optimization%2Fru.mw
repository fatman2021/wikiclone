<languages />

Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

Флаги CFLAGS и CXXFLAGS - это переменные среды, которые используются для сообщения компиляторам GNU Compiler Collection, <code>gcc</code> , какие виды ключей использовать при компиляции исходного кода. CFLAGS используются для кода написанного на C, в то время как флаги CXXLFAGS - для кода написанного на C++. 

Они могут быть использованы для уменьшения количества отладочных сообщений программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Invoking-GCC.html#Invoking-GCC GNU gcc handbook] поддерживает полный список доступных параметров и их предназначений. 

=== Как их использовать? ===

Флаги CFLAGS и CXXFLAGS могут использоваться двумя путями. Во-первых, они могут использоваться на уровне единственной программы с помощью make-файлов, генерируемых утилитой automake. 

Однако, Вы не должны делать этого при установке пакетов, находящихся в дереве портежей. Вместо этого, установите Ваши CFLAGS и CXXFLAGS флаги в {{Path|/etc/portage/make.conf}} . Таким образом все пакеты будут скомпилированы с использованием параметров, которые Вы укажете. 

{{Code|Флаги CFLAGS в /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Как видите, CXXFLAGS настроены на использование всех параметров, присутствующих в CFLAGS. Это то, что Вам потребуется почти безусловно. Вам вовсе не надобно указывать дополнительные параметры в CXXFLAGS. 

=== Заблуждения ===

В то время как CFLAGS и CXXFLAGS могут быть очень эффективными средствами генерации менее объемных или более быстрых двоичных файлов из исходного кода, они также могут нарушить функционирование Вашего кода, увеличить его объем, замедлить время исполнения, или вызвать серьезные ошибки компиляции! 

CFLAGS - это не панацея; они не смогут автоматически заставить Вашу систему работать быстрее или двоичные файлы занимать меньше места на диске. Добавление все большего и большего количества флагов в попытке оптимизировать (или "разогнать") систему - верный рецепт для неудачи. Существует точка, в которой Вы достигнете худших результатов. 

Вопреки хвастовству, которое Вы найдете в Интернете, агрессивные флаги компиляции CFLAGS и CXXFLAGS, скорее всего, принесут больше вреда, чем пользы для Ваших программ. Держите в уме, что причина, по которой флаги существуют с самого начала - это потому что они созданы для использования в определенном месте с определенной целью. Просто потому что один отдельный CFLAG хорош для одного участка кода, вовсе не означает что он подходит для компиляции всего, что Вы можете установить на Ваш компьютер! 

=== Готовы? ===

Теперь, когда Вы знаете о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций для Вашего компьютера. Они окажут Вам большую пользу и расположат к Вам разработчиков в следующий раз, когда Вы будете сообщать о проблеме на [http://bugs.gentoo.org Bugzilla] . (Разработчики обычно просят вас перекомпилировать пакет с минимальным количеством переменных CFLAGS для того, чтобы определить, продолжает ли проблема существовать. Запомните, агрессивные флаги могут разрушить код.) 

== Оптимизация ==

=== Основы ===

Целью использования CFLAGS и CXXFLAGS является создание кода, приспособленного под Вашу систему; он должен отлично функционировать, будучи легковесным и быстрым, если это возможно. Иногда это взаимоисключающие условия, поэтому мы будем придерживаться комбинаций, о которых известно, что они работают хорошо. В идеале, они являются легко доступными на любой архитектуре CPU. Мы упомянем два агрессивных флага позже, так чтобы Вы знали, чего следует остерегаться. Мы  не будем обсуждать каждый параметр, перечисленный в руководстве по <code>gcc</code>, но мы опишем основные, наиболее общие флаги. 

{{Note/ru|Если Вы не уверены что делает тот или иной флаг, проконсультируйтесь с соответствующей главой [http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options gcc manual] . Если Вы все еще не уверены, попробуйте Google, или посмотрите <code>gcc</code> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

Самой первым, и наиболее важным параметром, является <code>-march</code> . Он сообщает компилятору какой код он должен генерировать для Вашего типа процессора [http://en.wikipedia.org/wiki/Microarchitecture architecture] (или ''архитектуры'' ); он сообщает компилятору, что тот должен генерировать код для определенного типа CPU. Разные типы CPU имеют разные возможности, поддерживают различные наборы команд, и обладают разными способами исполнения кода. Флаг <code>-march</code> проинструктирует компилятор генерировать код специально для Вашего типа CPU, со всеми доступными возможностями, особенностями, наборами команд, интересными функциями, и так далее. 

Хотя переменная CHOST в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для Вашего конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU Вы имеете? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

А это другой пример для 64-разрядного AMD CPU: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Если Вы все еще не уверены, каким видом CPU Вы обладаете, вы можете просто использовать параметр <code>-march=native</code> . Когда используется этот флаг, GCC попытается распознать Ваш процессор и автоматически установит для него подходящие флаги. '''Однако, Вы не должны его использовать, если Вы собираетесь компилировать пакеты для другого CPU!''' 

Итак, если вы компилируете пакеты на одном компьютере, но собираетесь запускать их на другом (например, используя сборку на быстром компьютере для более медленного, старого компьютера), тогда ''не используйте'' <code>-march=native</code> . ''Native'' означает, что генерируемый код будет запускаться ''только'' на том типе CPU, на котором он был собран. Приложения скомпилированные с <code>-march=native</code> на процессоре AMD Athlon 64 CPU не смогут запуститься на более старом VIA C3 CPU. 

Также, доступны флаги <code>-mtune</code> и <code>-mcpu</code>. Эти флаги обычно использутся только тогда, когда нет доступного параметра <code>-march</code>; определенные архитектуры процессоров могут требовать <code>-mtune</code> или даже <code>-mcpu</code> . К сожалению, поведение <code>gcc</code> не весьма предсказуемо для того как эти флаги ведут себя при переходе от одной архитектуры к другой. 

На процессорах x86 и x86-64, параметр <code>-march</code> будет генерировать код, предназначенный специально для этих типов процессоров, используя все доступные наборы команд и корректный двоичный интерфейс приложений; он не будет обладать обратной совместимостью с более старыми/другими типами процессоров. Если Вам не требуется исполнять код на чем либо другом, кроме системы, на которой работает Gentoo, продолжайте использовать <code>-march</code> . Вы должны рассмотреть использование <code>-mtune</code> только тогда, когда Вам необходимо сгенерировать код для более старых процессоров, таких как i386 и i486. Параметр <code>-mtune</code> производит более общий код, чем <code>-march</code>; хотя он и настроит код под определенный процессор, он не будет рассматривать доступные наборы команд и двоичный интерфейс приложений. Не используйте <code>-mcpu</code> на системах с x86 или x86-64, так как это не рекомендуется для этих архитектур. 

Только не x86/x86-64 процессоры (такие как Sparc, Alpha, и PowerPC) могут потребовать параметры <code>-mtune</code> или <code>-mcpu</code> вместо <code>-march</code> . На этих архитектурах, <code>-mtune</code>/ <code>-mcpu</code> иногда будут вести себя как <code>-march</code> (на x86/x86-64) . . ., но с другим именем флага. Опять же, поведение <code>gcc</code> и именование флагов не является единообразным на каждой из архитектур, поэтому удостоверьтесь, что Вы проконсультировались с <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options manual], для того чтобы определить какой из них Вы должны использовать на своей системе. 

{{Note/ru|Для большего количества предполагаемых настроек <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code>, пожалуйста, прочитайте главу 5 подходящей [http://www.gentoo.org//doc/en/handbook/ настольной книги Gentoo] для Вашей архитектуры. Также, прочтите список руководств по [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options архитектурно-зависимым параметрам] <code>gcc</code>, наряду с более подробным объяснением различий между <code>-march</code> , <code>-mcpu</code> , и <code>-mtune</code> .}}

=== -O ===

Следующая по списку - переменная <code>-O</code> . Она управляет всем уровнем оптимизации. Это приводит к тому, что компиляция кода занимает больше времени, и сможет занять гораздо больше памяти, особенно когда  Вы увеличиваете уровень оптимизации. 

Существует пять видов настроек для переменной <code>-O</code>: <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , и <code>-Os</code> . Вы должны использовать только одну из них в {{Path|/etc/portage/make.conf}} . 

За исключением <code>-O0</code> , каждая из настроек с префиксом <code>-O</code> активирует несколько дополнительных флагов, поэтому удостоверьтесь, что Вы прочитали главу руководства gcc по [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options параметрам оптимизации] для изучения того, какие флаги активируются на каждом уровне с приставкой <code>-O</code>, также как и некоторые из объяснений того, что они делают. 

Давайте исследуем каждый уровень оптимизации: 

* <code>-O0</code> : Этот уровень (буква "O" и ноль за ней) отключает оптимизацию полностью и является уровнем по умолчанию, если никакого уровня с префиксом <code>-O</code> не указано в переменных CFLAGS или CXXFLAGS. Ваш код не будет оптимизирован; обычно это нежелательно.

* <code>-O1</code> : Это наиболее простой уровень оптимизации. Компилятор попытается сгенерировать быстрый, занимающий меньше объема код, без затрачивания наибольшего времени компиляции. Он достаточно простой, но должен всегда выполнять свою работу.

* <code>-O2</code> : Шаг вперед из <code>-O1</code> . Это ''рекомендуемый'' уровень оптимизации, до тех пор пока Вам не понадобится что-то особенное. <code>-O2</code> активирует несколько дополнительных флагов вдобавок к флагам, активированным на <code>-O1</code> . С параметром <code>-O2</code> , компилятор попытается увеличить производительность кода без нарушения размера, и без затрачивания большого количества времени компиляции.

* <code>-O3</code> : Это наибольший возможный уровень оптимизации, и также самый рискованный. С этим параметром, компиляция Вашего кода займет больше времени, и, фактически, он ''не должен использоваться глобально с <code>gcc</code> 4.x'' . Поведение <code>gcc</code> значительно изменилось с выходом версий 3.x. В версиях 3.x было продемонстрировано, что параметр <code>-O3</code> приводит к значительно более быстрому времени исполнения по сравнению с <code>-O2</code> , но это уже не так для <code>gcc</code> 4.x. Компилирование всех Ваших пакетов с параметром <code>-O3</code> ''приведет'' к большим по объему двоичным файлам, и значительно увеличит шансы ошибки компиляции или неожиданного поведения программы (включая ошибки). Недостатки перевешивают преимущества; вспомните закон убывающей предельной полезности. '''Использование параметра <code>-O3</code> не рекомендовано для <code>gcc</code> 4.x.''' 

* <code>-Os</code> : На этом уровне Ваш код будет оптимизирован по объему. Он активирует все параметры <code>-O2</code>, которые не приводят к увеличению размера генерируемого кода. Он может быть полезным на компьютерах, которые обладают чрезвычайно ограниченным пространством жесткого диска и/или имеют процессоры с небольшим размером кэша. Однако, он может вызвать достаточно много проблем, именно поэтому он отфильтровывается большинством сборочных файлов ebuild в дереве портежей. Использование <code>-Os</code> не рекомендуется.

Как упомянуто ранее, параметр <code>-O2</code> - рекомендуемый уровень оптимизации. Если компиляция пакета выдает сообщения об ошибках, убедитесь, что Вы не используете параметр <code>-O3</code> . В качестве выхода, попробуйте установить Ваши переменные CFLAGS и CXXFLAGS на наименьший уровень оптимизации, такой как <code>-O1</code>, или даже <code>-O0 -g2 -ggdb</code> (для сообщения об ошибках и проверки возможных проблем) и перекомпилируйте пакет. 

=== -pipe ===

A common flag is <code>-pipe</code> . This flag actually has no effect on the generated code, but it makes the compilation process faster. It tells the compiler to use pipes instead of temporary files during the different stages of compilation, which uses more memory. On systems with low memory, gcc might get killed. In that case, do not use this flag. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code> ) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the GNU <code>gcc</code> manual does not specify all architectures it is turned on by using <code>-O</code> , you will need to explicitly activate it on x86. However, using this flag will make debugging hard to impossible. 

In particular, it makes troubleshooting applications written in Java much harder, though Java is not the only code affected by using this flag. So while the flag can help, it also makes debugging harder; backtraces in particular will be useless. However, if you don't plan to do much software debugging and haven't added any other debugging-related CFLAGS such as <code>-ggdb</code> , then you can try using <code>-fomit-frame-pointer</code> . 

{{Important|Do ''not'' combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code> . Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.}}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

These flags enable the [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , and [http://en.wikipedia.org/wiki/3dnow 3DNow!] instruction sets for x86 and x86-64 architectures. These are useful primarily in multimedia, gaming, and other floating point-intensive computing tasks, though they also contain several other mathematical enhancements. These instruction sets are found in more modern CPUs. 

{{Important|Be sure to check if your CPU supports these by running <code>cat /proc/cpuinfo</code> . The output will include any supported additional instruction sets. Note that '''pni''' is just a different name for SSE3.}}

You normally don't need to add any of these flags to {{Path|/etc/portage/make.conf}} as long as you are using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code> ). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these you'll need to enable additional flags where appropriate after checking the output of <code>cat /proc/cpuinfo</code> . 

{{Note|You should check the [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options list] of x86 and x86-64-specific flags to see which of these instruction sets are activated by the proper CPU type flag. If an instruction is listed, then you don't need to specify it; it will be turned on by using the proper <code>-march</code> setting.}}

== Optimization FAQs ==

=== But I get better performance with -funroll-loops -fomg-optimize! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code> , <code>-fforce-mem</code> , <code>-fforce-addr</code> , and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

The truth of the matter is that they are dangerously aggressive flags. Take a good look around the [http://forums.gentoo.org Gentoo Forums] and [http://bugs.gentoo.org Bugzilla] to see what those flags do: nothing good! 

You don't need to use those flags globally in CFLAGS or CXXFLAGS. They will only hurt performance. They may make you sound like you have a high-performance system running on the bleeding edge, but they don't do anything but bloat your code and get your bugs marked INVALID or WONTFIX. 

You don't need dangerous flags like these. '''Don't use them''' . Stick to the basics: <code>-march</code> , <code>-O</code> , and <code>-pipe</code> . 

=== What about -O levels higher than 3? ===

Some users boast about even better performance obtained by using <code>-O4</code> , <code>-O9</code> , and so on, but the reality is that <code>-O</code> levels higher than 3 have no effect. The compiler may accept CFLAGS like <code>-O4</code> , but it actually doesn't do anything with them. It only performs the optimizations for <code>-O3</code> , nothing more. 

Need more proof? Examine the <code>gcc</code> [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup source code] : 

{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code> . 

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}} . Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code> , by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However,'''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers'' . Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers. 

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Gentoo Handbook, "Per-Package Environment Variables"] . 

== Resources ==

The following resources are of some help in further understanding optimization: 

* The [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/ GNU gcc manual] 

* Chapter 5 of the [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbooks] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* The [http://forums.gentoo.org Gentoo Forums]

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* nightmorph
