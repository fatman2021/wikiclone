<languages />

Это руководство предлагает введение в оптимизацию компилируемого кода используя безопасные, разумные флаги CFLAGS и CXXFLAGS. Оно также описывает теорию оптимизации в общих чертах.

== Введение ==

=== Что такое CFLAGS и CXXFLAGS? ===

Флаги CFLAGS и CXXFLAGS - это переменные среды, которые используются для сообщения компиляторам GNU Compiler Collection, <code>gcc</code> , какие виды ключей использовать при компиляции исходного кода. CFLAGS используются для кода написанного на C, в то время как флаги CXXLFAGS - для кода написанного на C++. 

Они могут быть использованы для уменьшения количества отладочных сообщений программы, увеличения уровня сообщений об ошибках, и, конечно же, оптимизации производимого кода. [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Invoking-GCC.html#Invoking-GCC GNU gcc handbook] поддерживает полный список доступных параметров и их предназначений. 

=== Как их использовать? ===

Флаги CFLAGS и CXXFLAGS могут использоваться двумя путями. Во-первых, они могут использоваться на уровне единственной программы с помощью make-файлов, генерируемых утилитой automake. 

Однако, Вы не должны делать этого при установке пакетов, находящихся в дереве портежей. Вместо этого, установите Ваши CFLAGS и CXXFLAGS флаги в {{Path|/etc/portage/make.conf}} . Таким образом все пакеты будут скомпилированы с использованием параметров, которые Вы укажете. 

{{Code|Флаги CFLAGS в /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Как видите, CXXFLAGS настроены на использование всех параметров, присутствующих в CFLAGS. Это то, что Вам потребуется почти безусловно. Вам вовсе не надобно указывать дополнительные параметры в CXXFLAGS. 

=== Заблуждения ===

В то время как CFLAGS и CXXFLAGS могут быть очень эффективными средствами генерации менее объемных или более быстрых двоичных файлов из исходного кода, они также могут нарушить функционирование Вашего кода, увеличить его объем, замедлить время исполнения, или вызвать серьезные ошибки компиляции! 

CFLAGS - это не панацея; они не смогут автоматически заставить Вашу систему работать быстрее или двоичные файлы занимать меньше места на диске. Добавление все большего и большего количества флагов в попытке оптимизировать (или "разогнать") систему - верный рецепт для неудачи. Существует точка, в которой Вы достигнете худших результатов. 

Вопреки хвастовству, которое Вы найдете в Интернете, агрессивные флаги компиляции CFLAGS и CXXFLAGS, скорее всего, принесут больше вреда, чем пользы для Ваших программ. Держите в уме, что причина, по которой флаги существуют с самого начала - это потому что они созданы для использования в определенном месте с определенной целью. Просто потому что один отдельный CFLAG хорош для одного участка кода, вовсе не означает что он подходит для компиляции всего, что Вы можете установить на Ваш компьютер! 

=== Готовы? ===

Теперь, когда Вы знаете о некоторых рисках, давайте посмотрим на некоторые из разумных, безопасных оптимизаций для Вашего компьютера. Они окажут Вам большую пользу и расположат к Вам разработчиков в следующий раз, когда Вы будете сообщать о проблеме на [http://bugs.gentoo.org Bugzilla] . (Разработчики обычно просят вас перекомпилировать пакет с минимальным количеством переменных CFLAGS для того, чтобы определить, продолжает ли проблема существовать. Запомните, агрессивные флаги могут разрушить код.) 

== Оптимизация ==

=== Основы ===

Целью использования CFLAGS и CXXFLAGS является создание кода, приспособленного под Вашу систему; он должен отлично функционировать, будучи легковесным и быстрым, если это возможно. Иногда это взаимоисключающие условия, поэтому мы будем придерживаться комбинаций, о которых известно, что они работают хорошо. В идеале, они являются легко доступными на любой архитектуре CPU. Мы упомянем два агрессивных флага позже, так чтобы Вы знали, чего следует остерегаться. Мы  не будем обсуждать каждый параметр, перечисленный в руководстве по <code>gcc</code>, но мы опишем основные, наиболее общие флаги. 

{{Note/ru|Если Вы не уверены что делает тот или иной флаг, проконсультируйтесь с соответствующей главой [http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options gcc manual] . Если Вы все еще не уверены, попробуйте Google, или посмотрите <code>gcc</code> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

Самой первым, и наиболее важным параметром, является <code>-march</code> . Он сообщает компилятору какой код он должен генерировать для Вашего типа процессора [http://en.wikipedia.org/wiki/Microarchitecture architecture] (или ''архитектуры'' ); он сообщает компилятору, что тот должен генерировать код для определенного типа CPU. Разные типы CPU имеют разные возможности, поддерживают различные наборы команд, и обладают разными способами исполнения кода. Флаг <code>-march</code> проинструктирует компилятор генерировать код специально для Вашего типа CPU, со всеми доступными возможностями, особенностями, наборами команд, интересными функциями, и так далее. 

Хотя переменная CHOST в {{Path|/etc/portage/make.conf}} и указывает основную используемую архитектуру, параметр <code>-march</code> все еще должен использоваться, так чтобы программы были оптимизированы для Вашего конкретного процессора. Процессоры x86 и x86-64 (в числе других) должны использовать флаг <code>-march</code>. 

Какой вид CPU Вы имеете? Чтобы это узнать, введите следующую команду: 

{{Cmd|cat /proc/cpuinfo}}

Давайте теперь рассмотрим <code>-march</code> в действии. Этот пример приведен для более старого чипа Pentium III: 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

А это другой пример для 64-разрядного AMD CPU: 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Если Вы все еще не уверены, каким видом CPU Вы обладаете, вы можете просто использовать параметр <code>-march=native</code> . Когда используется этот флаг, GCC попытается распознать Ваш процессор и автоматически установит для него подходящие флаги. '''Однако, Вы не должны его использовать, если Вы собираетесь компилировать пакеты для другого CPU!''' 

Итак, если вы компилируете пакеты на одном компьютере, но собираетесь запускать их на другом (например, используя сборку на быстром компьютере для более медленного, старого компьютера), тогда ''не используйте'' <code>-march=native</code> . ''Native'' означает, что генерируемый код будет запускаться ''только'' на том типе CPU, на котором он был собран. Приложения скомпилированные с <code>-march=native</code> на процессоре AMD Athlon 64 CPU не смогут запуститься на более старом VIA C3 CPU. 

Также, доступны флаги <code>-mtune</code> и <code>-mcpu</code>. Эти флаги обычно использутся только тогда, когда нет доступного параметра <code>-march</code>; определенные архитектуры процессоров могут требовать <code>-mtune</code> или даже <code>-mcpu</code> . К сожалению, поведение <code>gcc</code> не весьма предсказуемо для того как эти флаги ведут себя при переходе от одной архитектуры к другой. 

На процессорах x86 и x86-64, параметр <code>-march</code> будет генерировать код, предназначенный специально для этих типов процессоров, используя все доступные наборы команд и корректный двоичный интерфейс приложений; он не будет обладать обратной совместимостью с более старыми/другими типами процессоров. Если Вам не требуется исполнять код на чем либо другом, кроме системы, на которой работает Gentoo, продолжайте использовать <code>-march</code> . Вы должны рассмотреть использование <code>-mtune</code> только тогда, когда Вам необходимо сгенерировать код для более старых процессоров, таких как i386 и i486. Параметр <code>-mtune</code> производит более общий код, чем <code>-march</code>; хотя он и настроит код под определенный процессор, он не будет рассматривать доступные наборы команд и двоичный интерфейс приложений. Не используйте <code>-mcpu</code> на системах с x86 или x86-64, так как это не рекомендуется для этих архитектур. 

Только не x86/x86-64 процессоры (такие как Sparc, Alpha, и PowerPC) могут потребовать параметры <code>-mtune</code> или <code>-mcpu</code> вместо <code>-march</code> . На этих архитектурах, <code>-mtune</code>/ <code>-mcpu</code> иногда будут вести себя как <code>-march</code> (на x86/x86-64) . . ., но с другим именем флага. Опять же, поведение <code>gcc</code> и именование флагов не является единообразным на каждой из архитектур, поэтому удостоверьтесь, что Вы проконсультировались с <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options manual], для того чтобы определить какой из них Вы должны использовать на своей системе. 

{{Note/ru|Для большего количества предполагаемых настроек <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code>, пожалуйста, прочитайте главу 5 подходящей [http://www.gentoo.org//doc/en/handbook/ настольной книги Gentoo] для Вашей архитектуры. Также, прочтите список руководств по [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options архитектурно-зависимым параметрам] <code>gcc</code>, наряду с более подробным объяснением различий между <code>-march</code> , <code>-mcpu</code> , и <code>-mtune</code> .}}

=== -O ===

Следующая по списку - переменная <code>-O</code> . Она управляет всем уровнем оптимизации. Это приводит к тому, что компиляция кода занимает больше времени, и сможет занять гораздо больше памяти, особенно когда  Вы увеличиваете уровень оптимизации. 

Существует пять видов настроек для переменной <code>-O</code>: <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , и <code>-Os</code> . Вы должны использовать только одну из них в {{Path|/etc/portage/make.conf}} . 

За исключением <code>-O0</code> , каждая из настроек с префиксом <code>-O</code> активирует несколько дополнительных флагов, поэтому удостоверьтесь, что Вы прочитали главу руководства gcc по [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options параметрам оптимизации] для изучения того, какие флаги активируются на каждом уровне с приставкой <code>-O</code>, также как и некоторые из объяснений того, что они делают. 

Давайте исследуем каждый уровень оптимизации: 

* <code>-O0</code> : Этот уровень (буква "O" и ноль за ней) отключает оптимизацию полностью и является уровнем по умолчанию, если никакого уровня с префиксом <code>-O</code> не указано в переменных CFLAGS или CXXFLAGS. Ваш код не будет оптимизирован; обычно это нежелательно.

* <code>-O1</code> : Это наиболее простой уровень оптимизации. Компилятор попытается сгенерировать быстрый, занимающий меньше объема код, без затрачивания наибольшего времени компиляции. Он достаточно простой, но должен всегда выполнять свою работу.

* <code>-O2</code> : Шаг вперед из <code>-O1</code> . Это ''рекомендуемый'' уровень оптимизации, до тех пор пока Вам не понадобится что-то особенное. <code>-O2</code> активирует несколько дополнительных флагов вдобавок к флагам, активированным на <code>-O1</code> . С параметром <code>-O2</code> , компилятор попытается увеличить производительность кода без нарушения размера, и без затрачивания большого количества времени компиляции.

* <code>-O3</code> : Это наибольший возможный уровень оптимизации, и также самый рискованный. С этим параметром, компиляция Вашего кода займет больше времени, и, фактически, он ''не должен использоваться глобально с <code>gcc</code> 4.x'' . Поведение <code>gcc</code> значительно изменилось с выходом версий 3.x. В версиях 3.x было продемонстрировано, что параметр <code>-O3</code> приводит к значительно более быстрому времени исполнения по сравнению с <code>-O2</code> , но это уже не так для <code>gcc</code> 4.x. Компилирование всех Ваших пакетов с параметром <code>-O3</code> ''приведет'' к большим по объему двоичным файлам, и значительно увеличит шансы ошибки компиляции или неожиданного поведения программы (включая ошибки). Недостатки перевешивают преимущества; вспомните закон убывающей предельной полезности. '''Использование параметра <code>-O3</code> не рекомендовано для <code>gcc</code> 4.x.''' 

* <code>-Os</code> : На этом уровне Ваш код будет оптимизирован по объему. Он активирует все параметры <code>-O2</code>, которые не приводят к увеличению размера генерируемого кода. Он может быть полезным на компьютерах, которые обладают чрезвычайно ограниченным пространством жесткого диска и/или имеют процессоры с небольшим размером кэша. Однако, он может вызвать достаточно много проблем, именно поэтому он отфильтровывается большинством сборочных файлов ebuild в дереве портежей. Использование <code>-Os</code> не рекомендуется.

Как упомянуто ранее, параметр <code>-O2</code> - рекомендуемый уровень оптимизации. Если компиляция пакета выдает сообщения об ошибках, убедитесь, что Вы не используете параметр <code>-O3</code> . В качестве выхода, попробуйте установить Ваши переменные CFLAGS и CXXFLAGS на наименьший уровень оптимизации, такой как <code>-O1</code>, или даже <code>-O0 -g2 -ggdb</code> (для сообщения об ошибках и проверки возможных проблем) и перекомпилируйте пакет. 

=== -pipe ===

Общеупотребительный флаг - <code>-pipe</code> . Этот флаг не имеет влияет на генерируемый код, но он убыстряет процесс компиляции. Он сообщает компилятору, чтобы он использовал конвейер (pipe) вместо временных файлов в течение разных стадий компиляции, которые используют большее количество памяти. На системах с небольшим количеством памяти, gcc может завершить свою работу. В этом случае, не используйте этот флаг. 

=== -fomit-frame-pointer ===

Это очень широкоупотребительный флаг, предназначенный для того, чтобы уменьшить размер генерируемого кода. Он включается на всех уровнях с префиксом <code>-O</code> (исключая <code>-O0</code> ) на тех архитектурах, где это не затрудняет отладку (таких как x86-64), но Вам может быть нужно активировать его вручную для добавления к своим флагам. Хотя руководство по GNU <code>gcc</code> не указывает все архитектуры, на которых он включен с использованием параметра <code>-O</code> , Вам будет нужно явно активировать его для x86. Однако, использование этого флага может сделать отладку со сложной до невозможной. 

В частности, это делает устранение неполадок в Java-приложениях намного сложнее, хотя код, написанный на Java - не единственный, который затронут использованием этого флага. Поэтому, в то время как использование этого флага может помочь, оно также затрудняет отладку; трассировка стека, в частности, будет бесполезна. Однако, если Вы не планируете отлаживать большое количество программ и не добавляли какие-либо другие переменные CFLAGS, связанные с отладкой, такие как <code>-ggdb</code> , то Вы можете попытаться использовать <code>-fomit-frame-pointer</code> . 

{{Important/ru|''Не комбинируйте''<code>-fomit-frame-pointer</code> с подобным флагом <code>-momit-leaf-frame-pointer</code> . Использование последнего флага не рекомендуется, так как <code>-fomit-frame-pointer</code> уже выполняет всю работу. Кроме того, показано, что <code>-momit-leaf-frame-pointer</code> негативно влияет на производительность кода. }}

=== -msse, -msse2, -msse3, -mmmx, -m3dnow ===

Эти флаги разрешают наборы команд [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] , и [http://en.wikipedia.org/wiki/3dnow 3DNow!] для архитектур x86 и x86-64. Они используются в основном в мультимедиа, играх, и других вычислительных задачах с интенсивным использованием плавающей точки, хотя они также включают несколько других математических расширений. Эти наборы команд предоставляются большинством современных процессоров. 

{{Important/ru|Убедитесь, что Вы проверили Ваш процессор на их поддержку, введя команду <code>cat /proc/cpuinfo</code> . Результат будет включать любые дополнительные наборы команд, которые поддерживаются Вашим процессором. Заметьте, что '''pni''' - это просто другое имя для SSE3.}}

Обычно, Вы не нуждаетесь в добавлении каких-либо из этих флагов в {{Path|/etc/portage/make.conf}} пока Вы используете корректный параметр <code>-march</code> (например, <code>-march=nocona</code> подразумевает использование <code>-msse3</code> ). Некоторые заметные исключения - новые процессоры VIA и AMD64, которые поддерживают инструкции, не включаемые параметром <code>-march</code> (такие как SSE3). Для таких процессоров, Вам нужно включить дополнительные флаги, где это доступно, после проверки результата работы команды <code>cat /proc/cpuinfo</code> . 

{{Note/ru|Вы должны свериться со [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options списком флагов], характерных для архитектур x86 и x86-64, чтобы увидеть, какие из этих инструкций активированы соответствующим флагом типа процессора. Если инструкция перечислена, то Вам не нужно ее указывать; она будет включена подходящей настройкой <code>-march</code> .}}

== FAQ по оптимизации ==

=== Но я получаю лучшую производительность с -funroll-loops -fomg-optimize! ===

Нет, Вам только ''кажется'' что Вы получаете лучшую производительность, потому что кто-то Вас убедил в том, что чем больше флагов, тем лучше. Агрессивные флаги только повредят Вашим приложениям при глобальном использовании. Даже <code>gcc</code> [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options manual] говорит, что использование параметров <code>-funroll-loops</code> и <code>-funroll-all-loops</code> увеличит объем кода и время его исполнения. Хотя, по каким-то причинам, эти два флага, вместе с флагами <code>-ffast-math</code> , <code>-fforce-mem</code> , <code>-fforce-addr</code> , и им подобными, продолжают пользоваться популярностью среди гонщиков, которые хотят повысить чувство собственной важности. 

Истина в том, что это чрезвычайно агрессивные флаги. Посмотрите по [http://forums.gentoo.org форумам Gentoo] и [http://bugs.gentoo.org Bugzilla], чтобы увидеть, что эти флаги могут сделать: ничего хорошего! 

Вам не нужно использовать эти флаги глобально, в переменных CFLAGS и CXXFLAGS. Они только ухудшат производительность. Может показаться, что Вы имеете высокопроизводительную систему, работающую по последнему слову техники, но они не делают ничего, кроме раздувания кода и приводят к тому, что Ваши сообщения о багах помечаются как INVALID или WONTFIX. 

Вам не требуются такие опасные флаги, как эти. '''Не используйте их'''. Придерживайтесь основ: <code>-march</code> , <code>-O</code> , и <code>-pipe</code> . 

=== Что по поводу уровней оптимизации -O больших чем 3? ===

Некоторые пользователи хвалятся даже большей производительностью, достигнутой использованием <code>-O4</code> , <code>-O9</code> , и так далее, но в действительности, уровни <code>-O</code> большие чем 3 не имеют никакого эффекта. Компилятор может принимать переменные CFLAGS, такие как <code>-O4</code> , но, на самом деле, ничего с ними не делать. Он только выполняет оптимизацию до уровня <code>-O3</code> , и ничего больше: 

Нужно больше доказательств? Исследуйте [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup исходный код] <code>gcc</code> : 

{{Code|Исходный код параметра -O|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

Как видите, любое значение, большее тройки, рассматривается как <code>-O3</code> . 

=== А что об избыточных флагах? ===

Часто переменные CFLAGS и CXXFLAGS, которые включаются на разных уровнях <code>-O</code>, указаны избыточно в {{Path|/etc/portage/make.conf}} . Иногда, это сделано по неосведомленности, но также и для того, чтобы избежать отфильтровывание флагов или их замещение. 

Фильтрация/замещение флагов используется во многих ebuild-файлах, находящихся в дереве портежей. Обычно, это делается потому что пакеты не компилируются на определенных уровнях <code>-O</code>, или когда исходный код очень чувствителен к дополнительно используемым флагам. Ebuild-файл или отфильтровывает некоторые или все переменные CFLAGS и CXXFLAGS, или может заменить <code>-O</code> другим уровнем. 

[http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Руководство разработчика Gentoo] описывает в общих чертах, где и как работает фильтрация/замещение флагов. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code> , by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However,'''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers'' . Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers. 

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Gentoo Handbook, "Per-Package Environment Variables"] . 

== Resources ==

The following resources are of some help in further understanding optimization: 

* The [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/ GNU gcc manual] 

* Chapter 5 of the [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbooks] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* The [http://forums.gentoo.org Gentoo Forums]

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* nightmorph
