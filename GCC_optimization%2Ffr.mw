<languages />

Ce guide est une introduction à l'optimisation de code compilé en recourant à des variables CFLAGS et CXXFLAGS saines. Il présente aussi la théorie sousjacente à l'optimisation en général.

== Introduction ==

Que sont les variables CFLAGS et CXXFLAGS ?

CFLAGS et CXXFLAGS sont des variables d'environnement utilisées pour dire aux compilateurs de la collection GNU, <code>gcc</code>, quels types de commutateurs utiliser lors de la compilation du code source. CFLAGS concerne le code écrit en C, tandis que CXXFLAGS concerne le code écrite en C++. 

Elles peuvent être utilisées pour diminuer le nombre de messages de débogage pour un programme, augmenter le niveau d'alerte, et bien-sûr, optimiser le code produit.  Le [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Invoking-GCC.html#Invoking-GCC manuel de GNU gcc (en anglais)] tient à jour une liste exhaustive des options disponibles et de leurs objectifs. 

=== Comment sont-elles utilisées ? ===

Les variables CFLAGS et CXXFLAGS peuvent être utilisées de deux façons. Premièrement, elles peuvent être utilisées ''par programme'' dans des Makefiles générés par automake. 

Cependant, ceci ne devrait pas être fait lors de l'installation de paquets provenant de l'arbre de Portage. Au lieu de cela, définissez vos variables CFLAGS et CXXFLAGS dans le fichier {{Path|/etc/portage/make.conf}}. De cette manière, tous les paquets seront compilés en utilisant les options que vous y aurez définies. 

{{Code|CFLAGS in /etc/portage/make.conf|<pre>
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>
}}

Comme vous pouvez le voir, CXXFLAGS est définie pour utiliser toutes les options présentes dans CFLAGS. C'est ce que vous devriez faire sans risque la plupart du temps. Vous ne devriez jamais spécifier des options additionnelles dans CXXFLAGS. 

=== Erreurs de conception ===

ALors que CFLAGS et CXXFLAGS peuvent être un moyen efficace de produire des binaires plus compacts et/ou plus rapides, elles peuvent aussi empêcher votre code de fonctionner, augmenter sa taille, ralentir son exécution et même causer des erreurs de compilation. 

Les options de CFLAGS ne sont pas une baguette magique ; elles ne feront pas tourner votre système plus vite ou ne réduiront pas la taille de vos binaires automatiquement. Ajouter de plus en plus d'options dans l'espoir d'optimiser  votre système est une recette garantie d'échec. Il y a un point à partir duquel les retours seront négatifs. 

Malgré toute la vantardise que  vous trouverez sur Internet, des options de  CFLAGS et CXXFLAGS agressives créeront du tort à vos programmes plus qu'elles ne leur feront de bien. Souvenez-vous que  ces options ont été conçues pour être employées à des endroits précis pour des  objectifs précis.  La simple raison qu'une option particulière de CFLAGS est profitable à un morceau de code, ne signifie pas qu'elle convient à n'importe quelle  programme  que vous installerez sur votre machine ! 

=== Prêt ? ===

Maintenant que vous avez pris conscience des risques potentiels, jetons un coup d'œil à quelques optimisations saines et sûres pour votre ordinateur. Elles vous maintiendront en bons termes avec les développeurs la prochaine fois que vous rapporterez un problème sur [http://bugs.gentoo.org Bugzilla]. (Les développeurs vous demanderont généralement de recompiler un paquet avec des options de la variable CFLAGS minimales, pour voir si le problème subsiste. Souvenez-vous que des options agressives peuvent causer du tort à votre code.) 

== Optimiser ==

=== Les bases ===

L'objectif derrière l'utilisation des options des variables CFLAGS et CXXFLAGS est de créer un code parfaitement adapté à votre système ; il devrait fonctionner parfaitement tout en étant aussi compact et rapide que possible. Parfois, ces conditions sont incompatibles entre elles, c'est pourquoi nous nous en tiendrons à des combinaisons réputées pour bien fonctionner. Idéalement, elles sont les meilleurs disponibles pour toute architecture de processeur. Nous parlerons des options agressives plus tard, ainsi vous saurez à quoi vous en tenir. Nous ne discuterons pas chacune des options listées dans le manuel de  <code>gcc</code> (elles sont des centaines), mais nous couvrirons les options les plus basiques et courantes. 

{{Note|À chaque fois que vous ne savez pas ce que fait une option, reportez-vous au chapitre concerné du [http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options manuel de gcc] . Si vous restez perplexe, essayez un moteur de recherche, ou vérifiez la  [http://gcc.gnu.org/lists.html liste de diffusion] de  <code>gcc</code> .}}

=== -march ===

La première, et la plus importante, option est <code>-march</code>. Elle dit au compilateur quel code il devrait produire pour votre [http://en.wikipedia.org/wiki/Microarchitecture architecture] de processeur (ou ''arch'') ; elle dit qu'il devrait produire du code pour un certain type de processeur. Des processeurs différents ont des aptitudes différentes, prennent en charge différents jeux d'instructions et ont des manières différentes d'exécuter le code. L'option <code>-march</code> renseigne le compilateur pour qu'il produise le code spécifique à votre processeur, en tenant compte de toutes les aptitudes, fonctionnalités, jeux d'instructions, comportements, etc. de ce processeur. 

Même si la variable CHOST dans le fichier {{Path|/etc/portage/make.conf}} spécifie l'architecture générale utilisée, <code>-march</code> devrait quand même être utilisée pour que les programmes soient optimisés pour votre processeur spécifique.  Les processeur x86 et x86-64 (parmi d'autres) devrait utiliser l'option  <code>-march</code>. 

De quel type de processeur disposez-vous ? Pour le trouver, exécutez la commande suivante : 

{{Cmd|cat /proc/cpuinfo}}

Maintenant, regardons l'option  <code>-march</code> en action. Ceci est un exemple pour un ancien Pentium III : 

{{Code|/etc/portage/make.conf: Pentium III|<pre>
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>
}}

En voici un autre pour un processeur AMD 64-bit : 

{{Code|/etc/portage/make.conf: AMD64|<pre>
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>
}}

S'il vous reste un doute quand au type de votre processeur, vous pouvez utiliser l'option <code>-march=native</code>. Lorsque cette option est utilisée, GCC détecte automatiquement votre processeur et positionne lui-même  les options appropriées pour ce processeur. '''Néanmoins, celle-ci ne devrait pas être utilisée si votre intention est de compiler des paquets pour un autre processeur !''' 

Si vous compilez des paquets sur un ordinateur, mais avez l'intention les exécuter sur un autre (comme c'est parfois le cas lorsqu'on compile sur un ordinateur récent et rapide pour un ordinateur plus ancien et plus lent), alors ''n'utilisez pas'' l'option <code>-march=native</code>.
''Native'' signifie que ce code  s'exécutera ''seulement''  sur ce type de processeur. Les applications compilées avec l'option <code>-march=native</code> sur un processeur AMD Athlon 64 ne pourront pas tourner sur un ancien processeur VIA C3. 

Sont aussi disponibles, les options <code>-mtune</code> et <code>-mcpu</code>. Ces options sont normalement utilisées quand il n'y a pas d'option <code>-march</code> disponible ; certaines architecture de processeur peuvent demander les options<code>-mtune</code> ou même <code>-mcpu</code>. Malheureusement, le comportement de <code>gcc</code> n'est pas très cohérent sur la manière d'interpréter une option d'une architecture à une autre. 

Sur les processeurs x86 et x86-64, <code>-march</code> produira un code spécifique pour ce type de processeur en utilisant tout le jeu d'instructions disponibles et l'ABI (Application Binary Interface) correcte ; il n'y aura pas de rétrocompatibilité pour des processeurs plus anciens ou différents. Si vous n'avez pas besoin d'exécuter le code sur autre chose que le système sur lequel vous faites tourner Gentoo, continuez à utiliser  <code>-march</code>. Vous devriez seulement considérer l'utilisation de <code>-mtune</code>  pour le cas où vous avez besoin de générer du code pour un processeur plus ancien comme les i386 et I486. <code>-mtune</code>  produit un code plus générique que march</code> ; bien qu'il adapte le code pour un certain processeur, il ne prend pas en compte l'ensemble du jeu d'instructions et de l'ABI. N'utilisez pas <code>-mcpu</code>  sur des systèmes x86 ou x86-64,  car cette option est maintenant déconseillée pour ces architectures. 

Seuls les processeurs non x86/x-86-64 (comme Sparc, Alpha et PowerPC) peuvent nécessiter <code>-mtune</code> ou <code>-mcpu</code> plutôt que  <code>-march</code>.  Sur ces architectures, <code>-mtune</code>/ <code>-mcpu</code> donneront parfois des résultats identiques à ceux fournis par <code>-march</code> (sur x86/x86-64)... mais avec un nom d'option différent. Là encore, le comportement de <code>gcc</code>  et le nommage des options n'est pas cohérent à travers les différentes architectures, c'est pourquoi, vous devez consulter le [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-manuel des options ]  de <code>gcc</code>  pour déterminer laquelle utiliser pour votre système. 

{{Note|Pour plus de suggestions sur les réglages  <code>-march</code>/ <code>-mtune</code>/ <code>-mcpu</code>, lisez le chapitre 5 du  5 [http://www.gentoo.org//doc/fr/handbook/ manuel d'installation de Gentoo] adapté à votre architecture. Lisez aussi, la liste  des  [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options options spécifiques à l'architecture] du manuel de <code>gcc</code>, et les explications plus détaillées sur les différences entre  <code>-march</code> , <code>-mcpu</code> et <code>-mtune</code>.}}

=== -O ===

Vient ensuite l'option <code>-O</code>. Elle contrôle le niveau global d'optimisation. Ceci rend le temps de  compilation quelque peu plus long, et peut nécessiter plus de mémoire, en particulier si vous augmentez le niveau d'optimisation. 

Il y a 5 réglages de <code>-O</code> : <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> et <code>-Os</code>. Vous ne devriez en utiliser qu'un dans  {{Path|/etc/portage/make.conf}}. 

À l'exception de <code>-O0</code> ,les réglages de <code>-O</code> activent chacun une série d'options additionnelles, c'est pourquoi vous devriez lire le chapitre sur les  [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options  options d'optimisation] dans le manuel de  gcc, pour connaître les options qui sont activées par chacun des niveaux de   <code>-O</code>, et des explications sur ce qu'elles font. 

Examinons les différents niveaux d'optimisation : 

*  <code>-O0</code> : Ce niveau (la lettre O suivi du chiffre 0 ) supprime complètement toute optimisation et est la valeur par défaut si un aucune option <code>-O</code> n'est précisée dans  CFLAGS ou CXXFLAGS. Votre code ne sera pas optimisé, ce qui n'est pas, normalement, souhaité.

*  <code>-O1</code> : C'est le niveau d'optimisation le plus basique. Le compilateur va essayer de produire un code plus rapide et plus compact sans prendre trop de temps de compilation. C'est très basique mais ça fait toujours le travail.

*  <code>-O2</code> : Un échelon au-dessus de  <code>-O1</code> . C'est le niveau ''recommandé'' d'optimisation  si vous n'avez de besoin  spécifique.  <code>-O2</code> active quelques options de plus que <code>-O1</code> . Avec <code>-O2</code> , le compilateur va essayer d'augmenter la performance sans compromettre la taille et sans prendre trop de temps en compilation.

*  <code>-O3</code> : C'est le plus haut niveau d'optimisation possible mais aussi le plus risqué. Il prendra plus de temps en compilation et, en fait, il ne devrait pas être utilisé pour tout le système avec <code>gcc</code> 4.x'' . Le comportement de <code>gcc</code> a changé de manière significative  depuis la version 3.x. Avec  3.x, <code>-O3</code> s'est avéré ne produire qu'une amélioration de la vitesse marginale par rapport à   <code>-O2</code> , mais ce n'est plus le cas avec  <code>gcc</code> 4.x. Compiler tous vos paquets avec <code>-O3</code> ''donnera'' des binaires plus volumineux qui réclament plus de mémoire, et qui augmentera de manière significative les risque de plantage de la compilation ou de comportements inattendus des programmes (y compris des erreurs). Les inconvénients contrebalance les avantages ; rappelez-vous le principe de retours en diminution. '''Utiliser   <code>-O3</code> n'est pas recommandé avec <code>gcc</code> 4.x.''' 

*  <code>-Os</code> : Cette option optimise la taille de votre code. Elle active toutes les options activée par  <code>-O2</code> qui n'augmentent pas la taille du code. Elle peut être utile pour des machines qui ont un espace disque très limité et/ou ont des processeurs avec un cache de petite taille.
Néanmoins, elle peut engendrer quelques problèmes, ce qui explique pourquoi, cette option est rejetée par beaucoup d'ebuilds dans l'arbre de Portage.   Utiliser <code>-Os</code> n'est pas recommandé.

Comme mentionné précédemment, <code>-O2</code> est le niveau d'optimisation recommandé. Si des erreurs de compilation se produisent, vérifiez que vous n'utilisez pas  <code>-O3</code> . Comme option de repli, essayez de définir un niveau d'optimisation plus faible dans  CFLAGS et CXXFLAGS, comme  <code>-O1</code> ou même <code>-O0 -g2 -ggdb</code> (pour le rapport des erreurs et la vérification de problèmes possibles) et recompilez le paquet. 

=== -pipe ===

Une option commune est <code>-pipe</code>. Celle-ci n'a aucun effet sur le code produit, mais réduit le temps de compilation. Elle indique au compilateur d'utiliser des ''pipelines'' pendant la compilation à la place de fichiers temporaires  qui requièrent plus de mémoire. Sur les systèmes avec peu de mémoire, gcc peut se retrouver tué. Dans un tel cas, n'utilisez pas cette option. 

=== -fomit-frame-pointer ===

C'est une option très commune conçue pour réduire la taille du code généré. Elle est activée pour tous les niveaux de l'option <code>-O</code> (excepté <code>-O0</code> ) sur les architectures pour lesquelles procéder de cette manière n'interfère pas avec le débogage (comme x86-64), mais vous pouvez avoir besoin de l'activer vous-même en l'ajoutant à vos options. Bien que le manuel de GNU <code>gcc</code> ne précise pas toutes les architectures sur lesquelles cette option est activée par l'utilisation de l'option GNU <code>gcc</code>, vous pourrez avoir besoin de l'activer sur x86. Néanmoins, l'utilisation de cette option rendra le débogage difficile voire impossible. 

En particulier, cela rend le dépannage des applications écrites en Java beaucoup plus difficile, même si Java n'est pas le seul code affecté par l'utilisation de cette option. C'est pourquoi même si l'option apporte des bénéfices, elle rend le débogage plus difficile ; les ''backtraces'' en particulier seront inutiles. Cependant, si vous n'envisagez pas de faire beaucoup de débogage, et n'avez pas ajouté d'autres options en rapport avec le débogage à CFLAGS comme <code>-ggdb</code>, alors vous pouvez essayer d'utiliser <code>-fomit-frame-pointer</code>. 

{{Important| ''Ne combinez pas'' <code>-fomit-frame-pointer</code> avec l'option similaire  <code>-momit-leaf-frame-pointer</code> . Utiliser cette dernière option est déconseillé car <code>-fomit-frame-pointer</code> fait déjà le travail proprement. De plus, <code>-momit-leaf-frame-pointer</code> a démontré un impact négatif sur la performance du code.}}

=== -msse, -msse2, -msse3, -mmmx et -m3dnow ===

Ces options activent les  jeux d'instructions [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] et  [http://en.wikipedia.org/wiki/3dnow 3DNow!] pour les architectures x86 and x86-64. Ils sont utiles avant tout dans le multimedia, les jeux et autres applications utilisant les calculs en virgule flottante de manière intensive, bien qu'ils incluent aussi plusieurs autres améliorations mathématiques. Ces jeux d'instructions se rencontrent dans les processeurs les plus modernes. 

{{Important|Vérifiez que votre processeur les prend en charge en exécutant la commande  <code>cat /proc/cpuinfo</code> . La sortie présentera tous les jeux d'instructions additionnels pris en charge. Notez que '''pni''' n'est qu'un nom différent pour  SSE3.}}

Vous n'avez normalement pas besoin d'ajouter ces options à  {{Path|/etc/portage/make.conf}} tant que vous utilisez l'option <code>-march</code> (par exemple, <code>-march=nocona</code> implique <code>-msse3</code> ). Quelques exceptions notables sont les processeurs plus récents VIA et AMD64 qui prennent en charge des instructions qui ne découlent pas de l'utilisation de   <code>-march</code> (telles que SSE3). Pour de tels processeurs, vous devrez activer des options additionnelles là ou c'est approprié après avoir vérifié la sortie de  <code>cat /proc/cpuinfo</code> . 

{{Note|Vous devriez vérifier la  [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options liste] des options spécifiques aux  x86 et x86-64 pour voir lesquels de ces jeux d'instructions sont activés par l'option  propre  au type de processeur. Si un jeu d'instruction est listé alors vous n'avez pas besoin de  le spécifier ; il sera  activé automatiquement par l'utilisation de l'option  <code>-march</code> propre au processeur.}}

== FAQs sur l'optimisation==

=== Mais j'obtiens de meilleures performance avec -funroll-loops -fomg-optimize ! ===

Non, vous le ''pensez'' uniquement parce que quelqu'un vous a convaincu qu'utiliser plus d'options agressives est mieux. Les options agressives ne feront qu'endommager vos applications quand elles sont utilisées à l'échelle du système entier. Même [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options manuel] de <code>gcc</code> dit qu'utiliser <code>-funroll-loops</code> et <code>-funroll-all-loops</code> rend le code plus volumineux et plus lent. Néanmoins, pour quelques obscures raisons, ces deux options, ainsi que <code>-ffast-math</code> , <code>-fforce-mem</code>, <code>-fforce-addr</code> et d'autres options similaires, continuent à être très populaires parmi ceux qui désirent avoir les droits les plus grands à la vantardise. 

La vérité sur ce sujet, c'est qu'il y a des options dangereusement agressives. Jetez donc un coup d'œil aux [http://forums.gentoo.org forums Gentoo ] et à  [http://bugs.gentoo.org Bugzilla] pour savoir ce que ces options font réellement : rien de bon ! 

Vous n'avez pas besoin d'utiliser ces options globalement dans CFLAGS ou CXXFLAGS. Cela ne fera que dégrader la performance. Elles peuvent vous faire penser que vous avez une haute performance en fonctionnant à la limite, mais elles ne font que faire grossir votre code et vous apporter des bogues marquées INVALID ou WONTFIX. 

Vous n'avez pas besoin de telles options dangereuses. '''Ne les utilisez pas !'''. Contentez-vous de vous en tenir aux basiques : <code>-march</code> , <code>-O</code> et <code>-pipe</code>. 

=== Que dire des niveaux  -O supérieurs à  3 ? ===

Quelques utilisateurs se vantent même d'obtenir une meilleure performance en utilisant <code>-O4</code> , <code>-O9</code>  et plus, mais en réalité, une option <code>-O</code> d'un niveau supérieur à 3 n'a aucun effet. Le compilateur peut accepter des options telles que <code>-O4</code>  pour CFLAGS, mais il n'en fait rien. Il ne cherche à optimiser que jusqu'à  <code>-O3</code>, rien de plus. 

Vous avez besoin de preuves ? Jetez un coup d'œil au [http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&view=markup code source]  de  <code>gcc</code> : 

{{Code|-O source code|<pre>
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>
}}

As you can see, any value higher than 3 is treated as just <code>-O3</code> . 

=== What about redundant flags? ===

Oftentimes CFLAGS and CXXFLAGS that are turned on at various <code>-O</code> levels are specified redundantly in {{Path|/etc/portage/make.conf}} . Sometimes this is done out of ignorance, but it is also done to avoid flag filtering or flag replacing. 

Flag filtering/replacing is done in many of the ebuilds in the Portage tree. It is usually done because packages fail to compile at certain <code>-O</code> levels, or when the source code is too sensitive for any additional flags to be used. The ebuild will either filter out some or all CFLAGS and CXXFLAGS, or it may replace <code>-O</code> with a different level. 

The [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Gentoo Developer Manual] outlines where and how flag filtering/replacing works. 

It's possible to circumvent <code>-O</code> filtering by redundantly listing the flags for a certain level, such as <code>-O3</code> , by doing things like: 

{{Code|Specifying redundant CFLAGS|<pre>
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>
}}

However,'''this is not a smart thing to do'''. CFLAGS are filtered for a reason! When flags are filtered, it means that it is unsafe to build a package with those flags. Clearly, it is ''not'' safe to compile your whole system with <code>-O3</code> if some of the flags turned on by that level will cause problems with certain packages. Therefore, you shouldn't try to "outsmart" the developers who maintain those packages. ''Trust the developers'' . Flag filtering and replacing is done for your benefit! If an ebuild specifies alternative flags, then don't try to get around it. 

You will most likely continue to run into problems when you build a package with unacceptable flags. When you report your troubles on Bugzilla, the flags you use in {{Path|/etc/portage/make.conf}} will be readily visible and you will be told to recompile without those flags. Save yourself the trouble of recompiling by not using redundant flags in the first place! Don't just automatically assume that you know better than the developers. 

=== What about LDFLAGS? ===

The Gentoo developers have already set basic, safe LDFLAGS in the base profiles, so you don't need to change them. 

=== Can I use per-package flags? ===

{{Warning|Using per-package flags complicates debugging and support. Make sure you mention in your bug reports if you make use of this feature and what the changes are you made.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [http://www.gentoo.org//doc/en/handbook/handbook-amd64.xml?part=3&chap=6#doc_chap2 Gentoo Handbook, "Per-Package Environment Variables"] . 

== Resources ==

The following resources are of some help in further understanding optimization: 

* The [http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/ GNU gcc manual] 

* Chapter 5 of the [http://www.gentoo.org//doc/en/handbook/ Gentoo Installation Handbooks] 

* <code>man make.conf</code>

* [http://en.wikipedia.org Wikipedia]

* The [http://forums.gentoo.org Gentoo Forums]

== Acknowledgements ==

We would like to thank the following authors and editors for their contributions to this guide:

* nightmorph
