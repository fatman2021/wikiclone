<languages />

{{Metadata|abstract=Ce guide est une introduction à l'optimisation du code compilé via des options de compilation CFlAGS et CXXFLAGS sûres et saines. Il décrit également la théorie de l'optimisation en général. }}

Ce guide est une introduction à l'optimisation de code compilé en recourant à des variables CFLAGS et CXXFLAGS saines. Il présente aussi la théorie sousjacente à l'optimisation en général.

== Introduction ==

Que sont les variables CFLAGS et CXXFLAGS ?

CFLAGS and CXXFLAGS are environment variables that are used to tell the GNU Compiler Collection (<kbd>gcc</kbd>) what kinds of switches to use when compiling source code. CFLAGS are for code written in C, while CXXFLAGS are for code written in C++. 

Elles peuvent être utilisées pour diminuer le nombre de messages de débogage pour un programme, augmenter le niveau d'alerte, et bien-sûr, optimiser le code produit.  Le [http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC manuel de  gcc (en anglais)] tient à jour une liste exhaustive des options disponibles et de leurs objectifs. 

=== Comment sont-elles utilisées ? ===

CFLAGS and CXXFLAGS can be used in two ways. First, they can be used per-program with Makefiles generated by <kbd>automake</kbd>. 

Cependant, ceci ne devrait pas être fait lors de l'installation de paquets provenant de l'arbre de Portage. Au lieu de cela, définissez vos variables CFLAGS et CXXFLAGS dans le fichier {{Path|/etc/portage/make.conf}}. De cette manière, tous les paquets seront compilés en utilisant les options que vous y aurez définies. 

{{CodeBox|title=CFLAGS in /etc/portage/make.conf|lang=bash|1=
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
}}

{{Important|While it is possible to have multiple lines in USE flags, doing the same in CFLAGS can and will result in problems with programs such as <kbd>cmake</kbd>. Make sure your CFLAGS declaration is on a single line, with as little whitespace as possible to avoid those issues. See {{Bug|500034}} as an example.}}

Comme vous pouvez le voir, CXXFLAGS est définie pour utiliser toutes les options présentes dans CFLAGS. C'est ce que vous devriez faire sans risque la plupart du temps. Vous ne devriez jamais spécifier des options additionnelles dans CXXFLAGS.

=== Erreurs de conception ===

ALors que CFLAGS et CXXFLAGS peuvent être un moyen efficace de produire des binaires plus compacts et/ou plus rapides, elles peuvent aussi empêcher votre code de fonctionner, augmenter sa taille, ralentir son exécution et même causer des erreurs de compilation. 

Les options de CFLAGS ne sont pas une baguette magique ; elles ne feront pas tourner votre système plus vite ou ne réduiront pas la taille de vos binaires automatiquement. Ajouter de plus en plus d'options dans l'espoir d'optimiser  votre système est une recette garantie d'échec. Il y a un point à partir duquel les retours seront négatifs. 

Malgré toute la vantardise que  vous trouverez sur Internet, des options de  CFLAGS et CXXFLAGS agressives créeront du tort à vos programmes plus qu'elles ne leur feront de bien. Souvenez-vous que  ces options ont été conçues pour être employées à des endroits précis pour des  objectifs précis.  La simple raison qu'une option particulière de CFLAGS est profitable à un morceau de code, ne signifie pas qu'elle convient à n'importe quelle  programme  que vous installerez sur votre machine ! 

=== Prêt ? ===

Maintenant que vous avez pris conscience des risques potentiels, jetons un coup d'œil à quelques optimisations saines et sûres pour votre ordinateur. Elles vous maintiendront en bons termes avec les développeurs la prochaine fois que vous rapporterez un problème sur [http://bugs.gentoo.org Bugzilla]. (Les développeurs vous demanderont généralement de recompiler un paquet avec des options de la variable CFLAGS minimales, pour voir si le problème subsiste. Souvenez-vous que des options agressives peuvent causer du tort à votre code.) 

== Optimiser ==

=== Les bases ===

The goal behind using CFLAGS and CXXFLAGS is to create code tailor-made to your system; it should function perfectly while being lean and fast, if possible. Sometimes these conditions are mutually exclusive, so we'll stick with combinations known to work well. Ideally, they are the best available for any CPU architecture. We'll mention the aggressive flags later so you know what to look out for. We won't discuss every option listed on the <kbd>gcc</kbd> manual (there are hundreds), but we'll cover the basic, most common flags. 

{{Note|Whenever you're not sure what a flag actually does, refer to the relevant chapter of the [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options GCC manual] . If you're still stumped, try Google, or check out the <kbd>gcc</kbd> [http://gcc.gnu.org/lists.html mailing lists] .}}

=== -march ===

La première, et la plus importante, option est <code>-march</code>. Elle dit au compilateur quel code il devrait produire pour votre [https://en.wikipedia.org/wiki/Microarchitecture architecture] de processeur (ou ''arch'') ; elle dit qu'il devrait produire du code pour un certain type de processeur. Des processeurs différents ont des aptitudes différentes, prennent en charge différents jeux d'instructions et ont des manières différentes d'exécuter le code. L'option <code>-march</code> renseigne le compilateur pour qu'il produise le code spécifique à votre processeur, en tenant compte de toutes les aptitudes, fonctionnalités, jeux d'instructions, comportements, etc. de ce processeur. 

Même si la variable CHOST dans le fichier {{Path|/etc/portage/make.conf}} spécifie l'architecture générale utilisée, <code>-march</code> devrait quand même être utilisée pour que les programmes soient optimisés pour votre processeur spécifique.  Les processeur x86 et x86-64 (parmi d'autres) devrait utiliser l'option  <code>-march</code>. 

De quel type de processeur disposez-vous ? Pour le trouver, exécutez la commande suivante : 

{{Cmd|cat /proc/cpuinfo}}

To get more details, including <code>march</code> and <code>mtune</code> values, use:

{{Cmd|<nowiki>gcc -c -Q -march=native --help=target</nowiki>}}

Maintenant, regardons l'option  <code>-march</code> en action. Ceci est un exemple pour un ancien Pentium III : 

{{FileBox|filename=/etc/portage/make.conf|title=Pentium III|lang=bash|1=
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
}}

En voici un autre pour un processeur AMD 64-bit : 

{{FileBox|filename=/etc/portage/make.conf|title=AMD64|lang=bash|1=
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
}}

S'il vous reste un doute quand au type de votre processeur, vous pouvez utiliser l'option <code>-march=native</code>. Lorsque cette option est utilisée, GCC détecte automatiquement votre processeur et positionne lui-même  les options appropriées pour ce processeur. '''Néanmoins, celle-ci ne devrait pas être utilisée si votre intention est de compiler des paquets pour un autre processeur !''' 

{{Warning|Do '''not''' use <code>-march{{=}}native</code> or <code>-mtune{{=}}native</code> in the <code>CFLAGS</code> or <code>CXXFLAGS</code> variables of {{Path|make.conf}} when compiling with <tt>[[Distcc#-march.3Dnative|distcc]]</tt>.}}

Si vous compilez des paquets sur un ordinateur, mais avez l'intention les exécuter sur un autre (comme c'est parfois le cas lorsqu'on compile sur un ordinateur récent et rapide pour un ordinateur plus ancien et plus lent), alors ''n'utilisez pas'' l'option <code>-march=native</code>.
''Native'' signifie que ce code  s'exécutera ''seulement''  sur ce type de processeur. Les applications compilées avec l'option <code>-march=native</code> sur un processeur AMD Athlon 64 ne pourront pas tourner sur un ancien processeur VIA C3. 

Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, <kbd>gcc</kbd>'s behavior isn't very consistent with how each flag behaves from one architecture to the next. 

Sur les processeurs x86 et x86-64, <code>-march</code> produira un code spécifique pour ce type de processeur en utilisant tout le jeu d'instructions disponibles et l'ABI (Application Binary Interface) correcte ; il n'y aura pas de rétrocompatibilité pour des processeurs plus anciens ou différents. Si vous n'avez pas besoin d'exécuter le code sur autre chose que le système sur lequel vous faites tourner Gentoo, continuez à utiliser  <code>-march</code>. Vous devriez seulement considérer l'utilisation de <code>-mtune</code>  pour le cas où vous avez besoin de générer du code pour un processeur plus ancien comme les i386 et I486. <code>-mtune</code>  produit un code plus générique que march</code> ; bien qu'il adapte le code pour un certain processeur, il ne prend pas en compte l'ensemble du jeu d'instructions et de l'ABI. N'utilisez pas <code>-mcpu</code>  sur des systèmes x86 ou x86-64,  car cette option est maintenant déconseillée pour ces architectures. 

Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code> (on x86/x86-64)... but with a different flag name. Again, <kbd>gcc</kbd>'s behavior and flag naming just isn't consistent across architectures, so be sure to check the <kbd>gcc</kbd> [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options manual] to determine which one you should use for your system. 

{{Note|For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate [[HandBook:Main_Page|Gentoo Installation Handbook]] for your arch. Also, read the <kbd>gcc</kbd> manual's list of [http://gcc.gnu.org/onlinedocs/gcc/Submodel-Options.html#Submodel-Options architecture-specific options], as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.}}

=== -O ===

Vient ensuite l'option <code>-O</code>. Elle contrôle le niveau global d'optimisation. Ceci rend le temps de  compilation quelque peu plus long, et peut nécessiter plus de mémoire, en particulier si vous augmentez le niveau d'optimisation. 

Il y a 5 réglages de <code>-O</code> : <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code> . Vous ne devriez en utiliser qu'un dans  {{Path|/etc/portage/make.conf}}. 

À l'exception de <code>-O0</code> ,les réglages de <code>-O</code> activent chacun une série d'options additionnelles, c'est pourquoi vous devriez lire le chapitre sur les  [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options  options d'optimisation] dans le manuel de  gcc, pour connaître les options qui sont activées par chacun des niveaux de   <code>-O</code>, et des explications sur ce qu'elles font. 

Examinons les différents niveaux d'optimisation : 

*  <code>-O0</code> : ce niveau (la lettre O suivi du chiffre 0 ) supprime complètement toute optimisation et est la valeur par défaut si un aucune option <code>-O</code> n'est précisée dans  CFLAGS ou CXXFLAGS. Ceci diminue le temps de compilation et peut améliorer les informations de débogage, mais quelques applications ne fonctionneront pas correctement sans que l'optimisation ne soit activée. Cette option n'est pas recommandée sauf dans un but de débogage.

*  <code>-O1</code> : C'est le niveau d'optimisation le plus basique. Le compilateur va essayer de produire un code plus rapide et plus compact sans prendre trop de temps de compilation. C'est très basique mais ça fait toujours le travail.

*  <code>-O2</code> : Un échelon au-dessus de  <code>-O1</code> . C'est le niveau ''recommandé'' d'optimisation  si vous n'avez de besoin  spécifique.  <code>-O2</code> active quelques options de plus que <code>-O1</code> . Avec <code>-O2</code> , le compilateur va essayer d'augmenter la performance sans compromettre la taille et sans prendre trop de temps en compilation.

*  <code>-O3</code> : C'est le plus haut niveau d'optimisation possible. Il active des optimisations qui sont coûteuses en terme de temps de compilation et d'usage de la mémoire. Compiler tous vos paquets avec <code>-O3</code> ne garantit pas une amélioration de la performance. En réalité, dans de nombreuses situation, cela ralentit le système  à cause des binaires plus volumineux qui réclament plus de mémoire. De plus cette option est réputé casser de nombreux paquets. C'est pourquoi  utiliser   <code>-O3</code> n'est pas recommandé.

 4.x.'''

*  <code>-Os</code> : Cette option optimise la taille de votre code. Elle active toutes les options activée par  <code>-O2</code> qui n'augmentent pas la taille du code. Elle peut être utile pour des machines qui ont un espace disque très limité et/ou ont des processeurs avec un cache de petite taille.

*  <code>-Og</code> : In gcc 4.8, un nouveau niveau d'optimisation général , -Og a été introduit.Il répond au besoin d'une compilation rapide et une amélioration du débogage tout en procurant un niveau de performance en exécution raisonnable.   Le ressenti en développement devrait être meilleur qu'avec le niveau d'optimisation <code>-O0</code>. Notez que <code>-Og</code> n'implique pas <code>-g</code>, il se contente de désactiver les optimisations qui pourrait interférer avec le débogage.

*  <code>-Ofast</code>: nouveau dans GCC 4.7, consiste en  <code>-O3</code> plus <code>-ffast math</code>, <code>-fno-protect-parens<c/ode>, et <code>-fstack-arrays</code>. Cette option brise la conformité stricte avec les normes, et n'est pas recommandée en utilisation.

Comme mentionné précédemment, <code>-O2</code> est le niveau d'optimisation recommandé. Si des erreurs de compilation se produisent, vérifiez que vous n'utilisez pas  <code>-O3</code> . Comme option de repli, essayez de définir un niveau d'optimisation plus faible dans  CFLAGS et CXXFLAGS, comme  <code>-O1</code> ou même <code>-O0 -g2 -ggdb</code> (pour le rapport des erreurs et la vérification de problèmes possibles) et recompilez le paquet.

=== -pipe ===

Une option commune est <code>-pipe</code>. Celle-ci n'a aucun effet sur le code produit, mais réduit le temps de compilation. Elle indique au compilateur d'utiliser des ''pipelines'' pendant la compilation à la place de fichiers temporaires  qui requièrent plus de mémoire. Sur les systèmes avec peu de mémoire, gcc peut se retrouver tué. Dans un tel cas, n'utilisez pas cette option. 

=== -fomit-frame-pointer ===

This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>) on architectures where doing so does not interfere with debugging (such as x86-64), but you may need to activate it yourself by adding it to your flags. Though the <kbd>gcc</kbd> manual does not specify all architectures it is turned on by using <code>-O</code>, you will need to explicitly activate it on x86, with <kbd>gcc</kbd> up to version 4.6 or when using <code>-Os</code>. However, using this flag will make debugging hard to impossible. 

En particulier, cela rend le dépannage des applications écrites en Java beaucoup plus difficile, même si Java n'est pas le seul code affecté par l'utilisation de cette option. C'est pourquoi même si l'option apporte des bénéfices, elle rend le débogage plus difficile ; les ''backtraces'' en particulier seront inutiles. Cependant, si vous n'envisagez pas de faire beaucoup de débogage, et n'avez pas ajouté d'autres options en rapport avec le débogage à CFLAGS comme <code>-ggdb</code>, alors vous pouvez essayer d'utiliser <code>-fomit-frame-pointer</code>. 

{{Important| ''Ne combinez pas'' <code>-fomit-frame-pointer</code> avec l'option similaire  <code>-momit-leaf-frame-pointer</code> . Utiliser cette dernière option est déconseillé car <code>-fomit-frame-pointer</code> fait déjà le travail proprement. De plus, <code>-momit-leaf-frame-pointer</code> a démontré un impact négatif sur la performance du code.}}

=== -msse, -msse2, -msse3, -mmmx et -m3dnow ===

Ces options activent les  jeux d'instructions [http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions SSE] , [http://en.wikipedia.org/wiki/SSE2 SSE2] , [http://en.wikipedia.org/wiki/SSSE3 SSE3] , [http://en.wikipedia.org/wiki/MMX MMX] et  [http://en.wikipedia.org/wiki/3dnow 3DNow!] pour les architectures x86 and x86-64. Ils sont utiles avant tout dans le multimedia, les jeux et autres applications utilisant les calculs en virgule flottante de manière intensive, bien qu'ils incluent aussi plusieurs autres améliorations mathématiques. Ces jeux d'instructions se rencontrent dans les processeurs les plus modernes. 

{{Important|Vérifiez que votre processeur les prend en charge en exécutant la commande  <code>cat /proc/cpuinfo</code> . La sortie présentera tous les jeux d'instructions additionnels pris en charge. Notez que '''pni''' n'est qu'un nom différent pour  SSE3.}}

Vous n'avez normalement pas besoin d'ajouter ces options à  {{Path|/etc/portage/make.conf}} tant que vous utilisez l'option <code>-march</code> (par exemple, <code>-march=nocona</code> implique <code>-msse3</code> ). Quelques exceptions notables sont les processeurs plus récents VIA et AMD64 qui prennent en charge des instructions qui ne découlent pas de l'utilisation de   <code>-march</code> (telles que SSE3). Pour de tels processeurs, vous devrez activer des options additionnelles là ou c'est approprié après avoir vérifié la sortie de  <code>cat /proc/cpuinfo</code> . 

{{Note|Vous devriez vérifier la  [http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_64-Options.html#i386-and-x86_64-Options liste] des options spécifiques aux  x86 et x86-64 pour voir lesquels de ces jeux d'instructions sont activés par l'option  propre  au type de processeur. Si un jeu d'instruction est listé alors vous n'avez pas besoin de  le spécifier ; il sera  activé automatiquement par l'utilisation de l'option  <code>-march</code> propre au processeur.}}

== FAQs sur l'optimisation==

=== Mais j'obtiens de meilleures performance avec -funroll-loops -fomg-optimize ! ===

No, you only ''think'' you do because someone has convinced you that more flags are better. Aggressive flags will only hurt your applications when used system-wide. Even the <kbd>gcc</kbd> [http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options manual] says that using <code>-funroll-loops</code> and <code>-funroll-all-loops</code> makes code larger and run more slowly. Yet for some reason, these two flags, along with <code>-ffast-math</code>, <code>-fforce-mem</code>, <code>-fforce-addr</code>, and similar flags, continue to be very popular among ricers who want the biggest bragging rights. 

La vérité sur ce sujet, c'est qu'il y a des options dangereusement agressives. Jetez donc un coup d'œil aux [https://forums.gentoo.org/ forums Gentoo ] et à  [https://bugs.gentoo.org/ Bugzilla] pour savoir ce que ces options font réellement : rien de bon ! 

Vous n'avez pas besoin d'utiliser ces options globalement dans CFLAGS ou CXXFLAGS. Cela ne fera que dégrader la performance. Elles peuvent vous faire penser que vous avez une haute performance en fonctionnant à la limite, mais elles ne font que faire grossir votre code et vous apporter des bogues marquées INVALID ou WONTFIX. 

Vous n'avez pas besoin de telles options dangereuses. '''Ne les utilisez pas !'''. Contentez-vous de vous en tenir aux basiques : <code>-march</code> , <code>-O</code> et <code>-pipe</code>.

=== Que dire des niveaux  -O supérieurs à  3 ? ===

Quelques utilisateurs se vantent même d'obtenir une meilleure performance en utilisant <code>-O4</code> , <code>-O9</code>  et plus, mais en réalité, une option <code>-O</code> d'un niveau supérieur à 3 n'a aucun effet. Le compilateur peut accepter des options telles que <code>-O4</code>  pour CFLAGS, mais il n'en fait rien. Il ne cherche à optimiser que jusqu'à  <code>-O3</code>, rien de plus. 

Need more proof? Examine the [https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/opts.c?view=markup source code]: 

{{CodeBox|title=-O source code|lang=bash|1=
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
}}

Comme vous pouvez le constater, aucune valeur supérieure à <code>-O3</code> n'est prise en compte.

=== What about compiling outside the target machine? ===

Some readers might wonder if compiling outside the target machine with a strictly inferior CPU or GCC sub-architecture will result in inferior optimization results (compared to a native compilation). The answer is simple: '''No'''.  Regardless of the actual hardware on which the compilation takes place and the CHOST for which GCC was built, as long as the same arguments are used <small>(except for <code>-march=native</code>)</small> and the same version of GCC is used <small>(although minor version might be different)</small>, the resulting optimizations are strictly the same.

To exemplify, if Gentoo is installed on a machine whose GCC's CHOST is ''i686-pc-linux-gnu'', and a [[Distcc]] server is setup on another computer whose GCC's CHOST is ''i486-linux-gnu'', then there is no need to be afraid that the results would be less optimal because of the strictly inferior sub-architecture of the remote compiler and/or hardware. The result would be as optimized as a native build, as long as the same options are passed to both compilers (and the <code>-march</code> parameter doesn't get a <code>native</code> argument).  In this particular case the target architecture needs to be specified explicitly as explained in [[Distcc#-march.3Dnative|Distcc and -march=native]].

The only difference in behavior between two GCC versions built targeting different sub-architectures is the implicit default argument for the <code>-march</code> parameter, which is derived from the GCC's CHOST when not explicitly provided in the command line.

=== Que dire des options  redondantes ? ===

Très souvent des options CFLAGS et CXXFLAGS qui sont activées par des niveaux de <code>-O</code>  sont spécifiées de manière redondante dans {{Path|/etc/portage/make.conf}}.  Quelques fois cela est fait par ignorance, mais c'est aussi fait pour éviter le filtrage d'options ou le remplacement d'options. 

Le filtrage/remplacement d'options est fait dans de nombreux ebuilds de l'arbre de Portage. C'est généralement fait parce que la compilation de certains paquets échoue à certains niveaux de  <code>-O</code>, ou quand le code source est trop sensible pour que des options supplémentaires soient ajoutées. L'ebuild soit filtrera quelques options de CFLAGS et CXXFLAGS, soit remplacera le niveau de  <code>-O</code> par un autre. 

Le [http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html Manuel du développeur de Gentoo]  indique quand et comment le filtrage/remplacement d'options  fonctionne. 

Il est possible de contrecarrer le filtrage de  <code>-O</code>  en listant de manière redondante les options d'un certain niveau, (tel que  <code>-O3</code>)  en faisant ceci : 

{{CodeBox|title=Specifying redundant CFLAGS|lang=bash|1=
CFLAGS="-O3 -finline-functions -funswitch-loops"
}}

Néanmoins, '''ce n'est pas très élégant de le faire.''' Les options de CFLAGS sont filtrées pour une raison ! Quand des options sont filtrées, cela signifie que ce n'est pas sûr de compiler un paquet avec de telles options. Clairement, ce n'est ''pas '' sûr de compiler tout votre système avec l'option <code>-O3</code> si quelques unes des options activées par ce niveau sont susceptibles de provoquer des problèmes à certains paquets. En conséquence, vous ne devriez pas essayer d'être ''plus intelligent'' que les développeurs qui maintiennent ces paquets. ''Faites confiance'' aux développeurs''' ! . Le filtrage et le remplacement d'options est fait pour votre intérêt ! Si un ebuild spécifie des options alternatives, n'essayez pas de l'éviter. 

Vous continuerez probablement à rencontrer des problèmes si vous compilez un paquet avec des options inacceptables. Quand vous rapportez vos problèmes sur Bugzilla, les options que vous utilisez dans {{Path|/etc/portage/make.conf}}  seront pleinement visibles et on vous demandera de recompiler le paquet sans ces options. Évitez d'avoir à recompiler en n'utilisant pas ces options redondantes dès l'origine ! Ne supposez pas de manière automatique que vous en savez plus que les développeurs.

=== Que dire de  LDFLAGS ? ===

Les développeurs de Gentoo ont déjà défini des options de base sûres de la variable LDFLAGS  dans les profils de base. Vous n'avez donc pas besoin de les changer. 

=== Puis-je utiliser des options par paquet ? ===

{{Warning/fr |L'utilisation d'options par paquet complique le débogage et l'assistance.  Pensez à signaler dans vos rapport de bogues si vous utilisez cette fonctionnalité et quels changements vous avez faits.}}

Information on how to use per-package environment variables (including CFLAGS) is described in the [[Handbook:AMD64/Portage/Advanced#Per-package_environment_variables|Gentoo Handbook, "Per-Package Environment Variables"]].

== Ressources ==

Les ressources suivantes vous seront utiles pour aller plus loin dans la compréhension de l'optimisation : 

* La  [http://gcc.gnu.org/onlinedocs/gcc/ documentation en ligne sur gcc ] 

* Chapter 5 of the [[Handbook:Main_Page|Gentoo Installation Handbooks]]

* <kbd>man make.conf</kbd>

* [https://en.wikipedia.org/ Wikipedia]

* Les  [https://forums.gentoo.org/ forums de Gentoo]

{{Migrated|originalauthors=nightmorph}}
