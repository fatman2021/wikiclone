== Converting to a btrfs Based System ==
This exercise is one example for re-basing a gentoo installation's root filesystem to use btrfs.  In this case, the existing system is an mdadm based mirror set using two 2tb drives at /dev/sda and /dev/sdb.  Two fresh 2tb drives have been added at /dev/sdc and /dev/sdd.

=== Existing Layout ===
* Simple two way mdadm mirror (raid1)
** 250mb /boot partition as ext3 with metadata=0.90
** 75gb / partition as ext4 with metadata=0.90
** 750gb /home partition as ext4 with metadata=1.2
** 1tb+ /vm partition as ext4 with metadata=1.2

The use of the older metadata format for /boot and / partitions allows grub-0.97 to find and boot the system without needing to resort to an initial ram device.

{{File|/boot/grub/grub.conf||<pre>
default 0
timeout 6
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title Gentoo Linux 3.8.13-gentoo
root (hd0,0)
kernel /boot/kernel-3.8.13-gentoo md=2,/dev/sda2,/dev/sdb2 root=/dev/md2
</pre>}}

{{File|/etc/fstab||<pre>
/dev/md1                /boot           ext3            defaults,noatime        1 2
/dev/md2                /               ext4            defaults,noatime        0 1
/dev/md3                /home           ext4            defaults,noatime        0 1
/dev/md4                /vm             ext4            defaults,noatime        0 1
</pre>}}


=== New Layout ===
* 250mb /boot partition as ext3 with metadata=0.90
* 1.9gb+ btfs partition with raid1 metadata and data

We are keeping the /boot as a simple software mirror in order to stay with grub-0.97 but will now need to use an initial ram filesystem.  The kernel will otherwise panic when it attempts to mount btrfs filesystems that need to have a btfs device scan done first.  We will be following the writeup for [[Early Userspace Mounting]] to build that filesystem.

Btrfs has been built into the kernel (not a module) along with lzo compression/decompression as that will be used to optimize space utilization and read performance on the system volumes.  Likewise, the raid modules used by mdadm are also builtins.

{{Kernel||<pre>
General setup  --->
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
Device Drivers  --->
  [*] Multiple devices driver support (RAID and LVM)  --->
    {*}   RAID support
    [*]     Autodetect RAID arrays during kernel boot
    <*>     Linear (append) mode
    <*>     RAID-0 (striping) mode
    {*}     RAID-1 (mirroring) mode
    {*}     RAID-10 (mirrored striping) mode
    {*}     RAID-4/RAID-5/RAID-6 mode
File systems  --->
  <*> Btrfs filesystem support
  [*]   Btrfs POSIX Access Control Lists
</pre>}}

There are a number of places where lzo is part of a module name in the kernel .config.

{{RootCmd|cd /usr/src/linux}}
{{RootCmd|grep -i lzo .config|output=<pre>
CONFIG_HAVE_KERNEL_LZO=y
# CONFIG_KERNEL_LZO is not set
CONFIG_RD_LZO=y
CONFIG_SQUASHFS_LZO=y
CONFIG_CRYPTO_LZO=m
CONFIG_LZO_COMPRESS=y
CONFIG_LZO_DECOMPRESS=y
CONFIG_DECOMPRESS_LZO=y
</pre>}}

It's unclear what kernel options are pickable to make sure that the lzo module btrfs relies on will be enabled.  The likely suspect is CONFIG_HAVE_KERNEL_LZO which comes in to play for the compression of the kernel image itself:

{{Kernel||<pre>
General setup  --->
  Kernel compression mode (Gzip)  --->
    (X) Gzip
    ( ) Bzip2
    ( ) LZMA
    ( ) XZ
    ( ) LZO
</pre>}}

The default selection of Gzip causes CONFIG_KERNEL_LZO to not be set as shown above.  There doesn't appear to be a way to control the setting of CONFIG_HAVE_KERNEL_LZO short of editing .config directly.


==== Partitioning ====
cfdisk was used to partition /dev/sdc with the 250mb and remainder partitions by hand.  sfdisk then can be used to apply the same scheme to /dev/sdd

{{RootCmd|sfdisk -d /dev/sdc >/tmp/sdc.txt}}
{{RootCmd|sfdisk -d /dev/sdc >/tmp/sdc.txt|output=<pre>
# cat /tmp/sdc.txt
# partition table of /dev/sdc
unit: sectors

/dev/sdc1 : start=       63, size=   481887, Id=83, bootable
/dev/sdc2 : start=   481950, size=3906547218, Id=83
/dev/sdc3 : start=        0, size=        0, Id= 0
/dev/sdc4 : start=        0, size=        0, Id= 0
</pre>}}
{{RootCmd|# sfdisk /dev/sdd </tmp/sdc.txt}}

==== Setting up boot ====

{{RootCmd|mdadm --create --verbose /dev/md5 --level{{=}}mirror --raid-devices{{=}}2 --metadata{{=}}0.90 /dev/sdc1 /dev/sdd1|output=<pre>
mdadm: size set to 240832K
mdadm: array /dev/md5 started.
</pre>}}
{{RootCmd|cat /proc/mdstat {{|}} grep md5|output=<pre>
md5 : active raid1 sdd1[1] sdc1[0]
</pre>}}
{{RootCmd|mkfs -t ext3 /dev/md5|output=<pre>
mke2fs 1.42.7 (21-Jan-2013)
/dev/md5 alignment is offset by 512 bytes.
This may result in very poor performance, (re)-partitioning suggested.
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=4 blocks, Stripe width=4 blocks
60240 inodes, 240832 blocks
12041 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
30 block groups
8192 blocks per group, 8192 fragments per group
2008 inodes per group
Superblock backups stored on blocks: 
        8193, 24577, 40961, 57345, 73729, 204801, 221185

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done 
</pre>}}

The warning about /boot partition alignment might have been avoided with some more care with cfdisk.  It will be interesting to see what happens when the btrfs filesystem is created.  Grub must be installed on each of the new mirrors by hand as shown

{{Code|/boot transfer|<pre>
# mkdir /mnt/altboot
# mount -t ext3 /dev/md5 /mnt/altboot
# cd /boot
# tar cpf - . | (cd /mnt/altboot; tar xpf -)
# grub
grub> device (hd0) /dev/sdc

grub> root (hd0,0)
 Filesystem type is ext2fs, partition type 0x83

grub> setup (hd0)
 Checking if "/boot/grub/stage1" exists... yes
 Checking if "/boot/grub/stage2" exists... yes
 Checking if "/boot/grub/e2fs_stage1_5" exists... yes
 Running "embed /boot/grub/e2fs_stage1_5 (hd0)"...  22 sectors are embedded.
succeeded
 Running "install /boot/grub/stage1 (hd0) (hd0)1+22 p (hd0,0)/boot/grub/stage2 /boot/grub/menu.
lst"... succeeded
Done.
grub> device (hd0) /dev/sdd

grub> root (hd0,0)
 Filesystem type is ext2fs, partition type 0x83

grub> setup (hd0)
 Checking if "/boot/grub/stage1" exists... yes
 Checking if "/boot/grub/stage2" exists... yes
 Checking if "/boot/grub/e2fs_stage1_5" exists... yes
 Running "embed /boot/grub/e2fs_stage1_5 (hd0)"...  22 sectors are embedded.
succeeded
 Running "install /boot/grub/stage1 (hd0) (hd0)1+22 p (hd0,0)/boot/grub/stage2 /boot/grub/menu.
lst"... succeeded
Done.

grub> quit

</pre>}}

==== Transfer of / ====
We assume that a "hot" transfer of the system will be okay and thus do a remount of / to /mnt/rawroot to grab the basics without pulling in any additional baggage from /proc, udev and other mounts.  The new btfs will have the rootfs as a subvolume.  Other existing filesystem such as /home and /vm will become other subvolumes.  We edit /etc/fstab on an interim basis to provide mountpoints for the new filesystem and its subvolumes.  The compression and auto defragmentation features of btrfs may or may not be applicable for the underlying data.  The lzo compressor has been turned off for /mnt/newdistfiles since it will be getting the contents of /usr/portage/distfiles where files are already compressed.  The /mnt/newvm filesystem leaves out autodefrag as an option since it interferes with the performance of virtual machines and copy on write.

{{Code|/etc/fstab additions|<pre>
LABEL=BTRFSMIRROR	/mnt/btrfsmirror	btrfs	defaults,noatime	0 0
LABEL=BTRFSMIRROR	/mnt/newroot		btrfs	defaults,noatime,compress=lzo,autodefrag,subvol=root	0 0
LABEL=BTRFSMIRROR	/mnt/newhome		btrfs	defaults,noatime,compress=lzo,autodefrag,subvol=home	0 0
LABEL=BTRFSMIRROR	/mnt/newdistfiles	btrfs	defaults,noatime,autodefrag,subvol=distfiles	0 0
LABEL=BTRFSMIRROR	/mnt/newvm		btrfs	defaults,noatime,compress=lzo,subvol=vm	0 0
</pre>}}

{{Code|btrfs creation|<pre>
# mkfs.btrfs -L BTRFSMIRROR --d raid1 -m raid1 /dev/sdc2 /dev/sdd2

WARNING! - Btrfs Btrfs v0.19 IS EXPERIMENTAL
WARNING! - see http://btrfs.wiki.kernel.org before using

adding device /dev/sdd2 id 2
fs created label BTRFSMIRROR on /dev/sdc2
        nodesize 4096 leafsize 4096 sectorsize 4096 size 3.64TB
Btrfs Btrfs v0.19

# mkdir /mnt/btrfsmirror
# mount /mnt/btrfsmirror

# mkdir /mnt/newroot
# btrfs subvolume create /mnt/btrfsmirror/root
Create subvolume '/mnt/btrfsmirror/root'
# mount /mnt/newroot

# mkdir /mnt/newhome
# btrfs subvolume create /mnt/btrfsmirror/home
Create subvolume '/mnt/btrfsmirror/home'
# mount /mnt/newhome

# mkdir /mnt/newdistfiles
# btrfs subvolume create /mnt/btrfsmirror/distfiles
Create subvolume '/mnt/btrfsmirror/distfiles'
# mount /mnt/newdistfiles

# mkdir /mnt/newvm
# btrfs subvolume create /mnt/btrfsmirror/vm
Create subvolume '/mnt/btrfsmirror/vm'
# mount /mnt/newvm

# df
Filesystem      1K-blocks      Used  Available Use% Mounted on
rootfs           71959568  25451008   42846548  38% /
/dev/md2         71959568  25451008   42846548  38% /
devtmpfs         12332984         4   12332980   1% /dev
tmpfs            12367228      1056   12366172   1% /run
shm              12367228        84   12367144   1% /dev/shm
cgroup_root         10240         0      10240   0% /sys/fs/cgroup
cachedir             4096         4       4092   1% /lib64/splash/cache
/dev/md1           186555     51950     124973  30% /boot
/dev/md3        720795012 298068320  386105780  44% /home
/dev/md4       1129522164 978970760   93168360  92% /vm
/dev/md5           233225     52460     168724  24% /mnt/altboot
/dev/sdd2      3906547216      1128 3904391680   1% /mnt/btrfsmirror
/dev/sdd2      3906547216      1128 3904391680   1% /mnt/newroot
/dev/sdd2      3906547216      1128 3904391680   1% /mnt/newhome
/dev/sdd2      3906547216      1128 3904391680   1% /mnt/newdistfiles
/dev/sdd2      3906547216      1128 3904391680   1% /mnt/newvm
</pre>}}

We kick off the root fs transfer and come back after a cup of whatever.

{{Code|root fs copy (roughly 30 mins)|<pre>
# mkdir /mnt/rawroot
# mount --bind / /mnt/rawroot
# cd /mnt/rawroot
# tar cvpf - . | (cd /mnt/newroot; tar xpf -)
</pre>}}

Copy over the /home and other files as necessary.  In this particular install, /usr/portage/distfiles had been a softlink to a directory on the old /home filesystem.  If it was to have been split off from a physical directory instead, the transfer from the new root subvolume's usr/portage/distfiles to the newdistfiles subvolume is effectively a move between filesystems that would involve a copy and then a delete.  It would be more efficient to make judicious use of the -exclude switch on tar when doing the initial copy to the new mirror set.

==== Edit Config on New Mirror ====

Edit the grub.conf and fstab on the new mirror set to reflect the way things should look when the new mirror set becomes the boot set.  That includes editing /etc/mdadm.conf to assemble only the /dev/md1 device now.  It's also probably cleaner to do a mountpoint for /distfiles as shown and then have /usr/portage/distfiles be a softlink to it.

{{Code|/etc/fstab changes on new mirror|<pre>
/dev/md1                /boot           ext3    defaults,noatime                1 2
#/dev/md2		/		ext4		defaults,noatime	0 1
#/dev/md3		/home		ext4		defaults,noatime	0 1
#/dev/md4		/vm		ext4		defaults,noatime	0 1
LABEL=BTRFSMIRROR	/mnt/btrfsmirror	btrfs	defaults,noatime	0 0
LABEL=BTRFSMIRROR	/		btrfs	defaults,noatime,compress=lzo,autodefrag,subvol=root	0 0
LABEL=BTRFSMIRROR	/home		btrfs	defaults,noatime,compress=lzo,autodefrag,subvol=home	0 0
LABEL=BTRFSMIRROR	/distfiles	btrfs	defaults,noatime,autodefrag,subvol=distfiles	0 0
LABEL=BTRFSMIRROR	/vm		btrfs	defaults,noatime,compress=lzo,subvol=vm	0 0
</pre>}}

Generate a new mdadm.conf file to include the new /dev/md5 /boot mirror but then edit it to rename that to /dev/md1.  The other existing arrays are stubbed out, but the information is there in case the old mirror set is put back on again.

{{Code|new mdadm.conf|<pre>
# cd /mnt/newroot/etc
# mdadm --detail --scan >mdadm.conf
(edit as noted)
# cat mdadm.conf
#ARRAY /dev/md1 metadata=0.90 UUID=a4e5e7b8:b2ce2666:78a9b883:5f5f67d5
#ARRAY /dev/md2 metadata=0.90 UUID=881a4c3b:3cc63489:78a9b883:5f5f67d5
#ARRAY /dev/md3 metadata=1.2 name=whatever:3 UUID=9be86c4f:2b0a9e82:b70f0ccc:1eb9b458
#ARRAY /dev/md4 metadata=1.2 name=whatever:4 UUID=3f51c3cd:64b9aefa:957dde49:e1130638
ARRAY /dev/md1 metadata=0.90 UUID=651f4200:d2f48834:c68863d8:e9942ea0

</pre>}}

If this was a simple one disk based btrfs root filesystem the following process would probably work just fine.  Edit the new grub.conf to use the new btrfs based root filesystem.  Use rootflags to pull in the mount options from your new fstab for the root device.  Because we had used a label BTRFSMIRROR when making the new mirror set, we can pass that as the root to have the kernel automatically scan for and find the default volume.

{{Code|grub.conf on new boot mirror|<pre>
default 0
timeout 6
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title Gentoo Linux 3.8.13-gentoo
root (hd0,0)
kernel /boot/kernel-3.8.13-gentoo root=LABEL=BTRFSMIRROR rootflags=defaults,noatime,compress=lzo,autodefrag,subvol=root selinux=0

#title Gentoo Linux 3.8.13-gentoo
#root (hd0,0)
#kernel /boot/kernel-3.8.13-gentoo md=2,/dev/sda2,/dev/sdb2 root=/dev/md2 selinux=0

</pre>}}

However it turns out the kernel panics when it gets around to working with /rootfs.  So we will have to use an initial ram filesystem and an embedded init to mount the mirror set.  Following the wiki entry for [[Early Userspace Mounting]], we create the following files in /usr/src/linux/initramfs

{{File|initramfs_list|files to go into the initial ram fs|<pre>
# directory structure
dir /proc       755 0 0
dir /usr        755 0 0
dir /bin        755 0 0
dir /sys        755 0 0
dir /var        755 0 0
dir /lib64      755 0 0
dir /sbin       755 0 0
dir /mnt        755 0 0
dir /mnt/root   755 0 0
dir /etc        755 0 0
dir /root       700 0 0
dir /dev        755 0 0

# busybox
file /bin/busybox		/bin/busybox		755 0 0

#
# fsck deps
#
file /sbin/fsck			/sbin/fsck		755 0 0
file /lib64/libmount.so.1	/lib64/libmount.so.1	755 0 0
file /lib64/libblkid.so.1	/lib64/libblkid.so.1	755 0 0
file /lib64/libc.so.6		/lib64/libc.so.6	755 0 0
file /lib64/libuuid.so.1	/lib64/libuuid.so.1	755 0 0
file /lib64/ld-linux-x86-64.so.2  /lib64/ld-linux-x86-64.so.2 755 0 0

#
#  fsck.ext3 and added deps
#
file /sbin/fsck.ext3		/sbin/fsck.ext3		755 0 0
file /lib64/libext2fs.so.2	/lib64/libext2fs.so.2	755 0 0
file /lib64/libcom_err.so.2	/lib64/libcom_err.so.2	755 0 0
file /lib64/libe2p.so.2		/lib64/libe2p.so.2	755 0 0
file /lib64/libpthread.so.0	/lib64/libpthread.so.0	755 0 0

#
# btrfs utils and added deps
#
file /sbin/btrfs		/sbin/btrfs		755 0 0
file /sbin/btrfs-convert	/sbin/btrfs-convert	755 0 0
file /sbin/btrfs-debug-tree	/sbin/btrfs-debug-tree	755 0 0
file /sbin/btrfs-find-root	/sbin/btrfs-find-root	755 0 0
file /sbin/btrfs-image		/sbin/btrfs-image	755 0 0
file /sbin/btrfs-map-logical	/sbin/btrfs-map-logical	755 0 0
file /sbin/btrfs-restore	/sbin/btrfs-restore	755 0 0
file /sbin/btrfs-show		/sbin/btrfs-show	755 0 0
file /sbin/btrfs-vol		/sbin/btrfs-vol		755 0 0
file /sbin/btrfs-zero-log	/sbin/btrfs-zero-log	755 0 0
file /sbin/btrfsck		/sbin/btrfsck		755 0 0
file /sbin/btrfsctl		/sbin/btrfsctl		755 0 0
file /sbin/btrfstune		/sbin/btrfstune		755 0 0
file /sbin/mkfs.btrfs		/sbin/mkfs.btrfs	755 0 0
file /lib64/libz.so.1		/lib64/libz.so.1	755 0 0

#
#  init script
#
file    /init                   /usr/src/linux/initramfs/init             755 0 0

#
#  fstab
#
file	/etc/fstab		/usr/src/linux/initramfs/fstab	644 0 0

</pre>}}

{{File|fstab|minimal fstab for /mnt/root|<pre>
/dev/md1		/boot		ext3		defaults,noatime	1 2
LABEL=BTRFSMIRROR	/mnt/root	btrfs	defaults,noatime,compress=lzo,autodefrag,subvol=root	0 0
</pre>}}

{{File|init|initramfs init script|<pre>
#!/bin/busybox sh

rescue_shell() {
    echo "$@"
    echo "Something went wrong. Dropping you to a shell."
    busybox --install -s
    exec /bin/sh
}

mount_root() {
    echo "scanning for btrfs filesystems.... will take about 5-10 seconds"
    /sbin/btrfs device scan /dev/sda /dev/sdb
    echo "mounting /mnt/root"
    mount /mnt/root
}

check_filesystem() {
    # most of code coming from /etc/init.d/fsck

    local fsck_opts= check_extra= RC_UNAME=$(uname -s)

    # FIXME : get_bootparam forcefsck
    if [ -e /forcefsck ]; then
        fsck_opts="$fsck_opts -f"
        check_extra="(check forced)"
    fi

    echo "Checking local filesystem $check_extra : $1"

    if [ "$RC_UNAME" = Linux ]; then
        fsck_opts="$fsck_opts -C0 -T"
    fi

    trap : INT QUIT

    # using our own fsck, not the builtin one from busybox
    /sbin/fsck -p $fsck_opts $1

    case $? in
        0)      return 0;;
        1)      echo "Filesystem repaired"; return 0;;
        2|3)    if [ "$RC_UNAME" = Linux ]; then
                        echo "Filesystem repaired, but reboot needed"
                        reboot -f
                else
                        rescue_shell "Filesystem still have errors; manual fsck required"
                fi;;
        4)      if [ "$RC_UNAME" = Linux ]; then
                        rescue_shell "Fileystem errors left uncorrected, aborting"
                else
                        echo "Filesystem repaired, but reboot needed"
                        reboot
                fi;;
        8)      echo "Operational error"; return 0;;
        12)     echo "fsck interrupted";;
        *)      echo "Filesystem couldn't be fixed";;
    esac
    rescue_shell
}

# temporarily mount proc and sys
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev

# disable kernel messages from popping onto the screen
echo 0 > /proc/sys/kernel/printk

# clear the screen
clear

# mounting rootfs on /mnt/root
mount_root || rescue_shell "Error with uuidlabel_root"

echo "All done. Switching to real root."

# clean up. The init process will remount proc sys and dev later
umount /proc
umount /sys
umount /dev

# switch to the real root and execute init
exec switch_root /mnt/root /sbin/init

</pre>}}

'''Note''' - You will probably need to create the /usr/src/linux/initramfs directory before introducing the above files.  
{{Code||<pre>
# cd /usr/src/linux
# scripts/gen_initramfs_list.sh -o /mnt/altboot/initrd_btrfs.cpio.gz /usr/src//linux/initramfs/initramfs_list
</pre>}}


{{File|grub.conf|updated grub.conf on /mnt/altboot|<pre>
default 0
timeout 6
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title Gentoo Linux 3.8.13-gentoo
root (hd0,0)
kernel /boot/kernel-3.8.13-gentoo root=LABEL=BTRFSMIRROR rootflags=defaults,noatime,compress=lzo,autodefrag,subvol=root selinux=0
initrd /boot/initrd_btrfs.cpio.gz

</pre>}}

The init script is a hacked up version from the [[Early Userspace Mounting]] and will probably be cleaned up in a later edit.  The mount_root does a btrfs device scan which takes about 5-10 seconds depending on the drives being used.  That is the crucial piece that apparently doesn't get done when grub processes the kernel directive, and thus it can't figure out that btrfs is spanning more than one drive.

It would be a good idea to balance the new btrfs filesystems before booting into the new mirror set.  It isn't crucial to do it now, but it will speed up performance of the initial boot.  The balance can just as easily be done on the live volumes after the new mirror set is booted.
{{Cmd
|btrfs fi balance /mnt/newroot
|prompt=# 
|color=blue
}}
