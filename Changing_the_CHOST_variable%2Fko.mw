<languages />

{{Metadata|abstract=이 문서는 시스템에 있는 CHOST 변수 값을 바꾸는 방법을 설명합니다.}}

이 문서는 시스템에 있는 [[CHOST/ko|CHOST]] 변수 값을 바꾸는 방법을 설명합니다.

== 도입부 ==

CHOST 값을 바꾸는 일은 시스템 전체를 이상하게 꼬이게 할 수 있는 큰 문제입니다 - 그러니까 왜 그 모든 문제가 안내서에 있냐고요? 

CHOST 값을 어쩔 수 없이 바꿨을때 몇가지 상황이 발생하는데, 예컨대, nptl만 지원하는 glibc 2.4를 업그레이드 하려 하는데  CHOST 값을 nptl 사용이 불가능한 i386으로 설정한 경우를 찾을 때가 있습니다. 이 경우, 상당히 많은 옵션을 보유하지 않아, 이 옵션 중 CHOST 값을 바꿔야 합니다. 

이 절차를 따르더라도 문제가 발생할 수 있으니, 매우 조심스럽게 읽고 실행에 옮겼는지 확인 하십시오. 이 경우 CHOST 값이 i386에서 i686 으로 바뀌며, 다른 값을 바꿨을 경우 그에 따라 명령도 바꿉니다. 

== CHOST 변수 값 바꾸기 ==

===  꾸러미 빌드 ===

CHOST 값 바꾸기를 시작하려면, {{Path|/etc/portage/make.conf}} 파일을 편집하여 여러분이 필요에 맞춰 '''CHOST''' 값을 바꾸십시오. 다음 순서를 통해 다음 꾸러미를 다시 빌드하십시오: 

{{Emerge|binutils gcc glibc}}

{{Important|Please be aware that major gcc upgrades at the same time as changing CHOST (e.g. starting with gcc 3.3, CHOST i386 and switching to gcc 4.1, CHOST i686) can lead to severe side effects. While it may not be impossible to do so, it is hard to predict which potential problems may arise and document them in this guide. As a consequence, please do one thing at a time, e.g. upgrade gcc first according to our [[Upgrading_GCC|gcc upgrade guide]] and change your CHOST afterwards. If you are on a system with CHOST{{=}}i386, you will need to mask glibc 2.4 (or newer) during the gcc upgrade as it cannot be used with i386 and unmask it once you're done.}}

{{Note|It may be necessary to run <code>binutils-config</code> before compiling gcc.}}

=== 동작 확인 ===

Now it is time to make sure that your <code>gcc-config</code> and <code>binutils-config</code> settings are sane and you do not have any leftovers in {{Path|/etc/env.d/}}. 

<code>gcc-config</code>와 <code>binutils-config</code> 출력은 다음과 같아야 합니다(gcc 버전과 CHOST 값에 따라 다를 수 있으며, 여기는 GCC 4.1.1과 i686에 해당합니다): 

{{RootCmd|gcc-config -l|output=<pre>
 [1] i686-pc-linux-gnu-4.1.1 *</pre>}}

{{RootCmd|gcc-config -c|output=<pre>
i686-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|binutils-config -l|output=<pre>
 [1] i686-pc-linux-gnu-2.16.1 *
# binutils-config -c
i686-pc-linux-gnu-2.16.1
</pre>
}}

Next, check to see if there are references to the old CHOST in {{Path|/etc/env.d/}}: 

{{RootCmd|cd /etc/env.d/
|grep 386 *|output=<pre>
05gcc-i386-pc-linux-gnu:PATH="/usr/i386-pc-linux-gnu/gcc-bin/4.1.1"
05gcc-i386-pc-linux-gnu:ROOTPATH="/usr/i386-pc-linux-gnu/gcc-bin/4.1.1"
</pre>
}}

{{Note/ko|아무일도 안일어납니다만 이 경우 05gcc-i386-pc-linux-gnu에 오래된 CHOST 값 참조가 들어있습니다. 어떤 CHOST 값으로 바꾸느냐에 따라 시스템이 달라볼 수 있거나 그 상태로 괜찮을 수 있습니다. 이름은 05gcc-your_new_CHOST-pc-linux-gnu여야 합니다.}}

파일을 지우기 전에 업데이트한 CHOST 값이 파일에 붙었는지 확인하도록 하겠습니다: 

{{RootCmd|grep 686 *|output=<pre>
05binutils:MANPATH=/usr/share/binutils-data/i686-pc-linux-gnu/2.16.1/man
05binutils:INFOPATH=/usr/share/binutils-data/i686-pc-linux-gnu/2.16.1/info
05binutils:LDPATH=/usr/i686-pc-linux-gnu/lib
05gcc:PATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
05gcc:ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
05gcc:MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/man"
05gcc:INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/info"
05gcc:LDPATH="/usr/lib/gcc/i686-pc-linux-gnu/4.1.1"
</pre>
}}

여기서는 {{Path|/etc/env.d/}}의 (05gcc를 예로 들어)<code>gcc</code>에 대해서만 결과가 잘 나온것처럼 보이니, 잘못된 참조가 들어간 파일을 삭제하도록 하겠습니다: 

{{RootCmd|rm 05gcc-i386-pc-linux-gnu}}

이 같은 설정은 <code>binutils</code>에도 적용합니다 - 추가 요소가 있을 경우 오래된 요소를 찾아 삭제하십시오. 다음 {{Path|/etc/env.d/binutils/}} 디렉터리를 확인하십시오  

{{RootCmd|cd /etc/env.d/binutils/
|ls -la|output=<pre>
total 8
-rw-r--r-- 1 root root  15 Sep  3 13:48 config-i686-pc-linux-gnu
-rw-r--r-- 1 root root 126 Sep  3 13:48 i686-pc-linux-gnu-2.16.1
</pre>}}

{{RootCmd|cat config-i686-pc-linux-gnu|output=<pre>
CURRENT=2.16.1</pre>}}

{{RootCmd|cat i686-pc-linux-gnu-2.16.1|output=<pre>
TARGET="i686-pc-linux-gnu"
VER="2.16.1"
LIBPATH="/usr/lib/binutils/i686-pc-linux-gnu/2.16.1"
FAKE_TARGETS="i686-pc-linux-gnu"
</pre>
}}

보기 좋아보이는군요, 실제로 두 파일이 위치해 있습니다. 이제 gcc 디렉터리로 이동할 때입니다. 

{{RootCmd|cd /etc/env.d/gcc|output=<pre>
# ls -la
total 12
-rw-r--r-- 1 root root  32 Sep  3 16:43 config
-rw-r--r-- 1 root root  32 Aug  3 14:25 config-i386-pc-linux-gnu
-rw-r--r-- 1 root root 292 Sep  3 16:43 i686-pc-linux-gnu-4.1.1
</pre>}}

{{RootCmd|cat config|output=<pre>
CURRENT=i686-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|cat config-i386-pc-linux-gnu|output=<pre>
CURRENT=i386-pc-linux-gnu-4.1.1</pre>}}

{{RootCmd|cat i686-pc-linux-gnu-4.1.1|output=<pre>
PATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/4.1.1"
LDPATH="/usr/lib/gcc/i686-pc-linux-gnu/4.1.1"
GCCBITS="32"
MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/man"
INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/info"
STDCXX_INCDIR="g++-v4"
</pre>
}}

{{Path|config}}와 {{Path|i686-pc-linux-gnu-4.1.1}}은 괜찮지만 제거해야 할 {{Path|config-i386-pc-linux-gnu}}가 남아있습니다. 

{{Note/ko|다시 말해 오래된 GCC 버전 참조가 들어있는 파일 이름은 i686으로 바꾸더라도 config-i686-pc-linux-gnu 처럼 다를 수 있습니다. 이름 뿐만 아니라 파일의 내용을 확인하는 것도 중요합니다.}}

{{RootCmd|rm config-i386-pc-linux-gnu}}

이제 환경을 업데이트하려면 다음 명령을 실행하십시오: 

{{RootCmd|env-update && source /etc/profile}}

모든 문제를 고쳤는지 확인하십시오: 

{{RootCmd|grep -r 386 /etc/env.d/}}

아직도 뭔가가 있다면, 몇가지 빠진 파일을 보유하고, 계속 진행하기 전에 따라가봐야 합니다. 

=== 값 바꾸기 끝내기 ===

Now it is necessary to re-emerge <code>libtool</code> and run {{Path|/usr/share/gcc-data/$CHOST/<gcc-version>/fix_libtool_files.sh}}. Make sure to use the correct gcc version (your current one, 4.1.1 here) and pass your old architecture (i386 here) as argument. Replace $CHOST with your new CHOST, and <gcc-version> with your gcc version. This example assumes a CHOST of i686. 

{{Emerge|libtool}}

{{RootCmd|/usr/share/gcc-data/i686-pc-linux-gnu/4.1.1/fix_libtool_files.sh 4.1.1 --oldarch i386-pc-linux-gnu}}

모든 꾸러미를 다시 빌드하시는게 좋습니다: 

{{RootCmd|emerge -e world}}

이제, 이론적으로는 그리 할 필요가 없지만, 실제의 경우 100% 보장하진 못합니다. world를 대상으로 다시 컴파일 하는게 아니라면  최소한 다시 컴파일 할 필요가 있다는 몇가지 꾸러미를 언급했으니, 다음과 같이 하셔야 합니다: 

{{Emerge|python}}

All packages using perl install to the CHOST directory and hence need remerging. In case you haven't installed <code>qfile</code>, you will need to install {{Package|app-portage/portage-utils}} first. 

{{Emerge|portage-utils}}

{{RootCmd|emerge -av1 `qfile /usr/lib/perl* -Cq {{!}} sort -u`}}

다시 컴파일 해야 할 패키지가 아직도 몇개 있다면 이 문서를 작성한 저자에게 알려줏비시오.

=== 일반적인 문제 ===

CHOST 값을 바꾼 후 GCC 3.3에서 4.1로 업그레이드 할 때(어쨌든 이렇게 하지 마십시오), 꽤 많은 사람이 groff와 courier같은 꾸러미가 깨져 다시 컴파일해야 한다고 보고했습니다: 

{{Code|Error messsage|<pre>
error while loading shared libraries: libstdc++.so.5: cannot open shared object file: No such file or directory
</pre>
}}

This happens because during the upgrade, the CHOST doesn't exactly match CTARGET and the compiler assumes cross-compiling. As a consequence, LDPATH isn't inserted into {{Path|ld.so.conf}}, resulting in this error. 

Please see our [[Upgrading GCC|GCC upgrade guide]] for what needs to be rebuilt after a GCC upgrade. 

In some rare cases, this can break old versions of python, too. This may be fixed by adding {{Path|/usr/lib/gcc-lib/i386-pc-linux-gnu/3.3.6}} (change accordingly to your old chost and gcc version) to {{Path|/etc/ld.so.conf}}, running <code>ldconfig</code> and then <code>emerge libstdc++-v3</code>. However, as you can see, you really should avoid running into this problem - don't change CHOST and your gcc version at the same time.

=== 피드백 ===

That should be all, feedback (both if it worked, failed or other problems were encountered) is welcome, please send an email to {{Mail|amne@gentoo.org}} or post to [https://forums.gentoo.org/viewtopic-t-494147.html this forums thread]. Much in this howto comes from vapier, thanks for your help!

== 감사문 ==

이 안내서에 제공한 노고에 대해 다음 작성자와 편집자분들께 감사의 말을 전하고자 합니다:


* Wernfried Haas
* Mike Frysinger
* Chris White
